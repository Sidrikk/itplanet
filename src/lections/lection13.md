---
title: Лекция 13
category: lections
url: lection13
index: 13
topic: 9
---

09.03.02 Б1.О.10.7*- Методы и средства проектирования ИСиТ*

**Тема №9. «Проектирование пользовательского интерфейса»**

**Лекция 13. «Особенности проектирования графических интерфейсов с применением объектного подхода»**

**Цель лекции**: познакомить студентов с основами и компонентами проектирования пользовательского интерфейса, изучить операции создания объектов интерфейса, закрепить знания об их особенностях и применении.

**План:**

1.  Особенности графического интерфейса.
2.  Компоненты графического интерфейса.
3.  Объективный подход к проектированию интерфейса: общие правила взаимодействия с объектами.
4.  Операции пересылки и создания объектов.
5.  Проектирование окон и пиктограмм.
6.  Проектирование элементов управления: меню, кнопки, списки, текстовые области, панели инструментов, другие элементы.
7.  Проектирование средств поддержки пользователя.
8.  Средства реализации пользовательского интерфейса.

**Литература:**

\- Дубровский С.А. Методы обработки и анализа экспериментальных данных [Электронный ресурс] : учебное пособие / С.А. Дубровский, В.А. Дудина, Я.В. Садыева. — Электрон. текстовые данные. — Липецк: Липецкий государственный технический университет,

\- Интернет-ресурсы:

Открытый интернет ресурс «Studme.org» <https://studme.org/248225/informatika/kanonicheskoe_proektirovanie_informatsionnyh_sistem>

База данных «Studopedia.ru» <https://studopedia.ru/7_115487_kanonicheskoe-proektirovanie-is-i-osobennosti-ego-soderzhaniya.html>

1.  **Пользовательский интерфейс**

Графический пользовательский интерфейс – это система средств для взаимодействия пользователя с компьютером, основанная на представлении всех доступных пользователю системных объектов и функций в виде графических компонентов экрана.

Графические интерфейсы (*GUI — Graphical User Interface*) являются интерфейсами прямого манипулирования. Они сильно выигрывают в согласованности: когда прикладное программное обеспечение проектируется специально для такой операционной среды, все разработки управляются одинаковым способом, форматы ввода и вывода остаются теми же, данные легко передаются между разработками. Такие интерфейсы также обычно подразумевают стиль представления *WYSIWYG* (*What You See Is What You Get*), который обеспечивает непосредственное подтверждение введенных действий. Они также подразумевают наличие средств "отмены предыдущего действия" для возврата предшествующего состояния. Если объект можно удалить, «выбросив» его в мусорный ящик, то его можно будет восстановить, «достав» из ящика, по крайней мере, до тех пор, пока мусорщик не опустошит его. Тем не менее прямое манипулирование не всегда и не для всех является лучшим типом интерфейса. Во многих случаях опытному пользователю быстрее инициировать операцию, используя командный язык.

Еще одна важная особенность современных графических интерфейсов — это **многооконность.**

Многооконная технология обеспечивает пользователю доступ к большему объему информации, чем при использовании одного экрана. Кроме того, имея через окна доступ к нескольким источникам информации одновременно, пользователь может объединять имеющуюся в них информацию. Например, изображения, полученные с помощью графического редактора, можно включить в текстовый документ.

С помощью нескольких окон пользователь может также одновременно анализировать информацию, представленную на разных уровнях детализации. Наличие на экране нескольких окон или пиктограмм позволяет «расширить» кратковременную память пользователя.

Таким образом, графический интерфейс расширяет пространство обзора и облегчает работу пользователя (если рабочий стол «аккуратно организован»).

**Метафоры и технологии реализации оконных интерфейсов**

Как отмечалось ранее, управление процессом обработки или состоянием объекта осуществляется с помощью окон или пиктограмм. Приложение (а точнее, вычислительный процесс, реализуемый приложением) порождает визуальный объект - первичное окно или пиктограмму, - размещаемый на Рабочем столе и/или на Панели задач. Такой подход, при котором на экране открыто единственное окно, соответствующее выбранному пользователем объекту, обеспечивает взаимно однозначное визуальное соотношение между процессом и окном.

Обычно то окно, которое было открыто последним, отображается поверх других окон. Управление несколькими первичными окнами (перерисовка окна поверх других и переключение его в активное состояние), относящимися к разным приложениям, может выполняться средствами Рабочего стола и Панели задач, обеспечивая тем самым пользователей возможностью для переключения между приложениями. Некоторые типы объектов (например, устройства) могут даже не требовать создания собственного первичного окна и использовать только вторичное окно для просмотра и редактирования их свойств. Например, для так называемых консольных приложений единственным средством его визуального представления является пиктограмма.

Во многих случаях взаимодействие пользователя с приложением возможно в рамках единственного первичного окна, функциональность которого (при необходимости) расширяется за счет вторичных окон. Типичным примером такого решения является текстовый процессор *MS Word.*

Вместе с тем, для выполнения некоторых заданий может оказаться недостаточным одного первичного окна. Приложение, реализующее достаточно сложный процесс обработки, может использовать несколько окон, в том числе и для однотипных операций. Например, разработка программного обеспечения в интегрированных средах, администрирование баз данных, параллельная обработка текстовым процессором нескольких документов. В таких ситуациях работа приложения должна быть построена на основе многодокументного интерфейса.

**Многодокументный интерфейс** (*Multi Document Interface -* **MDI***)* основывается на использовании одного первичного окна, называемого родительским окном, которое может содержать набор связанных с ним дочерних окон. Каждое дочернее окно — это, по существу, такое же окно, как и первичное, единственным ограничением для которого является то, что оно может появиться только в пределах родительского окна. Родительское окно обеспечивает как визуальное, так и «операционное» пространство для открытых дочерних окон. На дочернее окно обычно распространяется область действия меню родительского окна и, возможно, других элементов его интерфейса (панели инструментов, строки состояния и т. д.). Их вид может изменяться, если необходимо отобразить команды и атрибуты активного дочернего окна.

Поскольку дочерние окна в *MDI* являются разновидностью первичных окон, при их закрытии следует придерживаться тех же соглашений, что и для первичных окон. Приложение не должно разрешить пользователю закрыть дочернее окно, если это не позволит ему продолжить работу с приложением.

Технология *MDI* имеет свои ограничения. В частности, когда пользователь открывает несколько файлов в пределах одного родительского окна, нарушается согласованность связи между дочерними окнами и между отображаемыми в них объектами. Несогласованность заключается в том, что хотя родительское окно визуально объединяет дочерние окна (играет роль контейнера), это не приводит к аналогичному объединению отображаемых файлов.

Такого рода недостатки *MDI* могут быть в значительной степени преодолены за счет применения альтернативных метафор, таких как **Рабочие области** (*Workspaces*), **Рабочие книги** (*Workbooks*) и **Проекты** (*Projects*). Хотя эти средства реализуют однооконную модель интерфейса, они тем не менее имеют ряд достоинств, присущих технологии MDI. В частности, с их помощью можно получить различные формы представления одних и тех же данных. Эти средства, реализуя принцип контейнера, обеспечивают большую гибкость относительно включаемых в них типов объектов. Но, как и любой контейнер, они ориентированы на управление только определенным типом объектов.

**Интерфейс типа Рабочая область** в отличие от *MDI* использует принцип функционального объединения отображаемых объектов. Это означает, что объекты, отображаемые в Рабочей области, могут соответствовать файлам, содержащимся в одном и том же контейнере. Внешне же соответствующие им окна выглядят как дочерние окна, расположенные в пределах родительского окна. Таким образом, концепция использования Рабочей области подобна концепции использования Рабочего стола, за исключением того, что она сама является объектом, который может быть представлен в виде пиктограммы и отображен в виде окна. Чтобы окно объекта могло появиться в Рабочей области, сам объект должен входить в состав соответствующего контейнера.

При управлении окнами в Рабочей области используются те же соглашения, что и в *МDI*-приложениях. Когда Рабочая область закрывается, все дочерние окна также закрываются.

Рабочая область должна обеспечить средства управления дочерними окнами в пределах Рабочей области. В частности, меню Окно и всплывающее меню родительского окна должны дополнительно содержать команды, предназначенные для прямой активизации и перемещения открытых дочерних окон.

**Интерфейс типа Рабочая книга** — это вариант формы представления обрабатываемых данных, в основе которого лежит *метафора книги*. В Рабочей книге различные типы данных представляются как отдельные разделы в пределах одного первичного окна. Типичным примером реализации Рабочей книги является *MS Excel.*

В качестве средства навигации между разделами Рабочей книги могут использоваться этикетки вкладок. Их расположение в Рабочей книге определяется разработчиком приложения в зависимости от содержания и организации отображаемой информации. Каждый раздел представляет данные, которые могли бы быть отдельным документом. В отличие от папки или Рабочей области, Рабочая книга лучше подходит для представления данных, которые могут быть определенным образом упорядочены и этот порядок имеет существенное значение. Кроме того, можно дополнительно включить раздел, перечисляющий содержание Рабочей книги подобно оглавлению обычной книги, который может быть использован как часть навигационного интерфейса.

**Интерфейс типа Проект** реализует способ управления окном, который предусматривает возможность отображения в одном окне взаимосвязанных объектов, представленных их пиктограммами. В этом смысле Проект подобен каталогу: для выбранного объекта открывается окно, которое относится к тому же уровню, что и родительское окно. В результате каждое дочернее окно Проекта может также иметь собственную кнопку входа на Панели задач. В отличие от каталога, Проект обеспечивает управление из родительского окна окнами входящих в него объектов. Например, когда пользователь, открыв документ, закрывает окно каталога, это никак не отражается на окне открытого документа. И напротив, когда пользователь закрывает окно Проекта, все окна его объектов также закрываются. Кроме того, когда пользователь открывает окно Проекта, это действие должно восстанавливать окна объектов в их предшествующем состоянии.

В целом, при выборе формы представления заданий или процессов, связанных с работой приложения, следует принимать во внимание целый ряд факторов: уровень знаний и навыков предполагаемых пользователей, особенности используемых объектов и решаемых с помощью приложения задач, требования к эффективному использованию пространства экрана монитора, а также ориентацию на разработку, управляемую данными. В тех случаях, когда структура объекта требует его представления одновременно в нескольких видах, или пользователю необходимо работать одновременно с несколькими объектами, более эффективным является применение технологии *МDI* либо использование Рабочих областей, Рабочих книги или Проектов. Эти конструкции обеспечивают формирование рабочей среды пользователя, ориентированной на выполнение определенного задания. При этом технология *MDI* является наиболее подходящей для работы с несколькими однотипными объектами, а использование Рабочих книг позволяет оптимизировать навигацию пользователя между различными представлениями одного объекта. Недостатком Рабочей книги можно считать то, что она ограничивает способность пользователя видеть одновременно несколько представлений объекта. Рабочие области и Проекты обеспечивают более гибкую технику для просмотра и совмещения объектов и их окон. Рабочая область используется в тех случаях, когда пользователю может потребоваться сгруппировать пиктограммы объектов (или их окна), используемые при выполнении некоторого задания. Применение Проекта позволяет снять ограничения на расположение и формат дочерних окон. Вместе с тем это преимущество достигается за счет увеличения сложности работы пользователя; кроме того, пользователю бывает весьма сложно отличить дочерние окна Проекта от окон других активных приложений. *MDI*, Рабочие области, Рабочие книги и Проекты допускают возможность совместного использования некоторых компонентов интерфейса несколькими окнами. В связи с этим пользователю всегда должно быть ясно, когда и в каком окне доступен конкретный элемент интерфейса.

1.  **Компоненты графического интерфейса**

**РАБОЧИЙ СТОЛ**

*Рабочий стол* предоставляет пользователю первичную рабочую область; он заполняет экран и формирует визуальный фон для всех выполняемых операций. Тем не менее, *Рабочий стол* является не просто фоном. Он может также быть использован в качестве основы для размещения объектов файловой системы. Кроме того, для компьютера, подключенного к сети, Рабочий стол служит в качестве частной рабочей области, через которую пользователь может получить доступ к другим объектам сети.

**ПИКТОГРАММЫ**

Пиктограммы используются для визуального представления на экране объектов или задач. Как правило, это небольшие законченные рисунки, отображающие сущность представляемых объектов или явлений. Поскольку пиктограммы являются одним из основных средств взаимодействия пользователя с приложением, важно не только обеспечить поддержку существующих (системных) пиктограмм, но и разработать новые; от того, насколько они будут соответствовать своему предназначению, будет зависеть и эффективность работы пользователя.

**ОКНА**

В реальном мире взгляд через разные окна позволяет получить различные изображения внешнего мира. Аналогичную роль играют окна и в графическом интерфейсе.

Формально понятие окна трактуется следующим образом: окно есть специальная область физического экрана, с помощью которой пользователь имеет возможность получить отображение определенного аспекта решаемой задачи.

Другими словами, окно является средством просмотра и редактирования информации, а также отображения содержимого и свойств объектов. Окна могут использоваться также для вывода на экран значений параметров, результатов выполнения команд, наборов инструментов и сообщений, информирующих пользователя о конкретной ситуации. Пользователь может взаимодействовать с объектами приложения, используя различные устройства ввода. Наиболее распространенные из них — мышь, клавиатура и перо.

**МАНИПУЛЯТОР**

Мышь является основным устройством ввода при использовании графического интерфейса. Другие типы устройств указания, которые эмулируют мышь (например, трекболы), также подпадают под этот общий термин.

Мышь функционально связана с графическим символом на экране, который называется **указателем.** Позиционируя указатель и нажимая или щелкая кнопку мыши, пользователь может выбирать объекты и операции.

По мере того, как пользователь перемешает указатель через экран, его форма может изменяться, чтобы обеспечить информирование пользователя **(обратную связь)** *о* конкретной позиции, операции или состоянии. Табл. 1 содержит некоторые наиболее распространенные формы указателя, используемые в MS Windows, и их назначение.

Каждый указатель имеет определенную точку, называемую **горячей точкой,** которая идентифицирует точную позицию указателя мыши на экране. Горячая точка определяет, на какой объект воздействует пользователь посредством мыши. Для объектов на экране может быть также определена горячая зона; **горячая зона** *—* это область, в пределах которой должна (или может) находиться горячая точка, чтобы считаться расположенной над объектом. Как правило, горячая зона совпадает с границами объекта, но может быть как больше, так и меньше, чтобы облегчить работу пользователя.

Таблица 1.

**Формы указателя**

| **Форма**                                              | **Позиция на экране**            | **Допустимое или выполняемое действие**                                 |
|--------------------------------------------------------|----------------------------------|-------------------------------------------------------------------------|
| ![](/static/lection-images/e2f73ea07dd4d1f913587a6d931282d0.png)        | Поверх большинства объектов      | Указание, выбор или перемещение                                         |
|                                                        | Над текстом                      | Выбор текста                                                            |
|                                                        | Над любым объектом или позицией  | Выполнение операции                                                     |
|                                                        | Над любым объектом или позицией  | Выполнение операции в фоновом режиме; указатель остается интерактивным  |
|                                                        | Поверх большинства объектов      | Режим контекстно-зависимой помощи                                       |
|                                                        | Внутри окна                      | Масштабирование изображения                                             |
|                                                        | Поверх регулируемой границы      | Изменение размера по вертикали                                          |
|                                                        | Поверх регулируемой границы      | Изменение размера по горизонтали                                        |
|                                                        | Поверх регулируемой границы      | Изменение размера по диагонали                                          |
|                                                        | Поверх регулируемой границы      | Изменение размера по диагонали                                          |
| ![](/static/lection-images/e3f8b09ff6303c0b7eb5df9f77d47e9d.png)        | Вдоль границы столбца            | Изменение ширины столбца                                                |
| ![](/static/lection-images/a0d5847c9ccab4ed44164540144fb3c8.png)        | Вдоль границы строки             | Изменение высоты строки                                                 |
| ![](/static/lection-images/2a5eb4127a55cdba89414432aa222dd7.png)        | Над блоком разбиения окна        | Изменение размера (ширины) вертикальных подокон                         |
| ![](/static/lection-images/4e1f0e9f4101a26d06011fd7a4b847cd.png)        | Над блоком разбиения окна        | Изменение размера (высоты) горизонтальных подокон                       |
| ![](/static/lection-images/b6d68c2250847998922d2f00f5863663.png)        | Над объектом-приемником          | Приемник недоступен для перетаскиваемого объекта                        |

Взаимодействие пользователя с приложением посредством мыши основано на использовании левой и правой кнопок мыши (в дальнейшем соответственно ЛКМ и ПКМ). Действия, выполняемые с помощью ПКМ, обычно дублируют функции, которые доступны через ЛКМ, но могут быть реализованы альтернативным способом.

В табл. 2 приведено описание основных действий, выполняемых с помощью мыши.

Таблица 2.

**Основные действия, выполняемые с помощью мыши.**

| **Действие**                       | **Описание**                                                                                                                                                                                                                                                                                                                      |
|------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Указание (*Pointing*)              | Установка указателя на конкретный объект на экране без использования кнопок мыши. Указание обычно является частью подготовки к выполнению некоторого другого действия. Для указания во многих случаях имеется возможность обеспечить визуальную обратную связь с пользователем (например, посредством изменения формы указателя)  |
| Щелчок  (*Clicking*)               | Щелчок одной из кнопок мыши на объекте; как правило, в момент щелчка мышь не перемещается; щелчок идентифицирует (выбирает) или активизирует объект                                                                                                                                                                               |
| Двойной щелчок (*Double-Clicking*) | «Сдвоенный» щелчок одной из кнопок мыши на объекте; объект, может быть, как выбран ранее, так и не выбран; двойной щелчок обеспечивает выполнение предопределенной операции для данного объекта                                                                                                                                   |
| Нажатие (*Pressing*)               | Предполагает установку указателя над одним из объектов (или позиций) на экране с последующим нажатием кнопки мыши; кнопка удерживается в нажатом состоянии достаточно продолжительное время (не менее 1с); обычно нажатие является начальной фазой операции выбора                                                                |
| Перемещение (*Dragging*)           | Перемещение указателя при нажатой кнопке мыши; как правило, используется для выполнения операций выбора и прямого манипулирования                                                                                                                                                                                                 |

Для большинства операций, выполняемых с помощью мыши, нажатие кнопки только идентифицирует начало выполнения операции. Сама же операция выполняется при освобождении кнопки. Исключением является функция **авто повторения.** Например, установив указатель на стрелку полосы прокрутки и удерживая нажатой кнопку мыши, можно обеспечить непрерывную прокрутку до тех пор, пока кнопка не будет отпущена.

**КЛАВИАТУРА**

Клавиатура — это основное средство ввода или редактирования текстовой информации. Тем не менее, при реализации графического интерфейса она может использоваться для ввода других типов данных, а также для управления, переключения режимов и как средство ускоренного доступа к объектам и операциям.

С точки зрения организации взаимодействия пользователя с объектами приложения все клавиши можно разделить на следующие функциональные группы:

-   текстовые клавиши и клавиши пунктуации;
-   клавиши навигации;
-   функциональные клавиши;
-   клавиши доступа;
-   клавиши режима;
-   клавиши-акселераторы.

**Клавиша доступа** (иногда именуемая также мнемонической клавишей) — это текстовая клавиша, которая при использовании в комбинации с клавишей \<*Al*t\> активизирует соответствующий элемент управления. Клавиша доступа должна соответствовать одному из символов текстовой метки этого элемента управления. Например, комбинация клавиш \<*Alt*\> + *О* может активизировать элемент управления, имеющий метку *Открыть.* Эффект активизации элемента управления зависит от типа этого элемента.

Клавиша доступа должна быть уникальной в пределах своей области действия (т.е. одна и та же клавиша не должна использоваться для доступа более чем к одному элементу управления, расположенному в этой области). В противном случае с помощью данной клавиши всегда будет активизироваться только один элемент — расположенный первым в этой области.

**Клавиши режима** изменяют способ действия других клавиш (или других устройств ввода). Различают два типа таких клавиш: клавиши-переключатели и клавиши-модификаторы.

**Клавиша-переключатель** включает или выключает конкретный режим при каждом очередном нажатии. Например, нажатие клавиши \<*Caps lock*\> приводит к переключению с верхнего регистра на нижний и наоборот.

**Клавиша-модификатор,** в отличие от клавиш-переключателей, устанавливает режим, который остаётся в силе, только пока клавиша-модификатор удерживается в нажатом состоянии. К ним относятся клавиши \<*Shift*\>, \<*Ctrl*\> и \<*Alt*\>. Их использование, во многих случаях, оказывается предпочтительнее из-за того, что они требуют привлечения внимания пользователя к выбору режима и, вместе с тем, позволяют легко отменить выбранный режим.

**Клавиши-акселераторы** (называемые также **горячими клавишами)** *—* это клавиши или комбинации клавиш, которые обеспечивают быстрый доступ к часто выполняемым операциям. В качестве таких комбинаций рекомендуется использовать \<*Сtrl*\> + \<символ\> и функциональные клавиши (с *Fl* no *F12*). По определению, клавиши-акселераторы являются «клавиатурным эквивалентом» других элементов пользовательского интерфейса. Исходя из этого, избегайте использования клавиши-акселератора как единственного средства доступа к какому-либо объекту или функции.

При назначении клавиш-акселераторов следует учитывать приведенные ниже рекомендации.

-   Используйте комбинацию \<*Shift*\> + \<клавиша\> для расширения или дополнения действия, выполняемого с помощью этой \<клавиши\> без \<*Shift*\>. Например, если комбинация клавиш \<*Alt*\> + \<*Tab*\> обеспечивает переключение между окнами сверху вниз, то комбинация \<*Shift*\> + \<*Alt*\> + \<*Tab*\> переключает окна в обратном порядке.
-   Используйте комбинации \<*Сtrl*\> + \<клавиша\> для усиления эффекта действия, выполняемого с помощью \<клавиши\>. Например, при редактировании текста клавиша \<*Ноmе*\> обеспечивает переход на начало строки, а комбинация \<Ctrl\> + \<Home\> — в начало текста.
-   Избегайте комбинаций \<*Alt*\> + \<клавиша\>, поскольку они могут конфликтовать со стандартным клавиатурным доступом к меню и элементам управления интерфейса. Комбинации \<*Alt*\> + \<*Tab*\>, \<*Alt*\> + \<*Esc*\> и \<*Alt*\> + \<*Spacebar*\> зарезервированы для системного использования; комбинации \<*Аlt*\> + \<цифра\> обеспечивают ввод специальных символов.
-   Учитывайте назначения клавиш-акселераторов, использованные разработчиками системного программного обеспечения. Например, в ОС *MS Windows* комбинация \<*Ctrl*\> + *C* используется для выполнения команды *Copy* (Копировать).
-   Предоставляйте пользователю право изменять назначения клавиш-акселераторов в вашем приложении, когда это возможно.

Некоторые клавиатуры содержат три новых клавиши: клавишу *\<Application\> (Приложение)* и две клавиши *\<Windows\> (Окна).* Основное назначение клавиши *\<Application\> —* вызов всплывающего меню для текущего выбора (т.е. она аналогична комбинации \<*Shift*\>+*F10*). Вы можете также использовать ее совместно с клавишами-модификаторами для выполнения специализированных функций приложения. Нажатие любой из клавиш *\<Windows\> —* левой или правой — приводит к появлению меню. Эти клавиши также используются системой как модификаторы для специфических системных функций. Не используйте эти клавиши в качестве модификаторов для функций несистемного уровня.

1.  **Объектный подход к проектированию интерфейса: общие правила взаимодействия с объектами.**

**Разработка, управляемая данными** (сокращенно *DCD — Data-centered Design*) означает, что проектирование интерфейса поддерживает такую модель взаимодействия пользователя с системой, при которой первичными являются обрабатываемые данные, а не требуемые для этого программные средства. Другими словами, при таком подходе основное внимание пользователя концентрируется на тех данных, с которыми он работает, а не на поиске и загрузке необходимого приложения.

При использовании *DCD*-технологии основным программным объектом является **документ,** который представляет собой некоторое абстрактное устройство хранения данных, используемых для выполнения заданий пользователей и для их взаимодействия. Документ должен быть доступен как различным приложениям, используемым для его обработки, так и всем взаимодействующим пользователям.

**ОБЪЕКТЫ И ОТНОШЕНИЯ МЕЖДУ НИМИ**

Рассмотренные выше особенности графических интерфейсов, а также положенная в основу их реализации *DCD*-технология обуславливают необходимость применения для проектирования *GUI* объектно-ориентированного подхода. Такой подход предполагает использование аналогий между программными объектами и объектами реального мира. С точки зрения пользовательского интерфейса, объектами являются не только файлы или пиктограммы, но и любое устройство для хранения и обработки информации, включая ячейки, параграфы, символы, и т.д., а также документы, в которых они находятся.

Объекты, независимо от того, относятся ли они к реальному миру или имеют компьютерное воплощение, обладают определенными характеристиками, которые помогают нам понимать, что они собой представляют, и как они ведут себя в тех или иных ситуациях. Следующие понятия описывают основные аспекты и характеристики объектов, имеющих компьютерное воплощение:

-   **Свойства объектов.** Объекты имеют определенные характеристики или атрибуты, называемые свойствами, которые определяют их представление или возможные состояния (например, цвет, размер, дату модификации). Свойства не ограничены внешними или видимыми признаками объекта. Они могут отражать их внутреннюю организацию или текущее состояние объекта.
-   **Операции над объектами.** Все действия, которые могут быть выполнены с (или над) объектом, считаются допустимыми операциями. Перемещение или копирование объекта являются примерами операций. Пользователь может выполнять операции над объектами, используя те или иные механизмы, предоставляемые интерфейсом, (в частности, командное управление и прямое манипулирование).
-   **Связь (отношения) между объектами.** Любой объект тем или иным образом взаимодействует с другими объектами. Во многих случаях взаимоотношения между объектами могут быть описаны как связь определенного типа. Наиболее общими типами отношений являются наборы (*Collection*), объединения (*Constraints*), и композиции (*Composites*).

**Набор** представляет собой наиболее простой тип отношения, которое отражает наличие у объектов некоторых общих свойств. Результаты запроса (поиска) по образцу или операции множественного выбора объектов — примеры использования данного типа отношения. Важным достоинством этого типа отношения является то, что он позволяет указывать операции, которые должны относиться к определенному набору объектов.

**Объединение** отражает более «тесное» отношение между объектами, при котором изменение объекта влияет на некоторый другой объект в наборе. Простейший пример такого отношения — изменение формата соседней страницы при добавлении текста на предыдущей странице документа.

**Композиция** имеет место в том случае, когда агрегация нескольких объектов может рассматриваться как новый объект со своим собственным множеством свойств и допустимых операций. Столбец ячеек в таблице и параграф в текстовом документе — это примеры композиций.

Еще один распространенный тип отношений между объектами — контейнер.

**Контейнер является** объектом, который содержит другие объекты (например, рисунок в документе или документ в папке могут рассматриваться как часть содержимого соответствующего контейнера). Свойства контейнера часто влияют на поведение его содержимого. Это влияние может заключаться в расширении или подавлении некоторых свойств содержащихся в нем объектов или в изменении перечня допустимых операций. Кроме того, контейнер управляет доступом к своему содержимому, а также преобразованием типа (формата) включаемого в него объекта. Это, в частности, может сказаться на результате пересылки объекта из одного контейнера в другой.

Рассмотренные выше аспекты обуславливают необходимость отнесения каждого объекта к тому или иному типу (классу) объектов. Объекты одного типа имеют аналогичные свойства и поведение.

Как и в реальном мире, совокупность объектов (возможно, различных типов) образует некоторую среду (окружение) пользователя. Исходя из этого, большинство заданий пользователя могут быть представлены (описаны) как определенная комбинация взаимосвязанных объектов. Так, например, обработка текстового документа может быть описана как композиция операций, выполняемых над его элементами (отдельными словами, параграфами и т.д.). Благодаря такому подходу любые, сколь угодно сложные конструкции могут быть реализованы на основе небольшого числа базовых соглашений. При условии последовательной и согласованной реализации этих соглашений для всего пользовательского интерфейса эффективность работы пользователя существенно возрастает. Кроме того, указанный подход способствует модульной, компонентно-ориентированной разработке приложения, то есть новое задание может быть выполнено путем адаптации или рекомбинации тех же объектов.

В реальном мире объекты сохраняют свое текущее состояние до тех пор, пока оно не будет изменено под влиянием каких-либо внешних воздействий. Например, если вы, уходя из дому, закрыли окно, оно, скорее всего, останется в таком же состоянии до вашего возвращения. Это же правило должно быть справедливо и для объектов интерфейса. За исключением тех случаев, когда требуется явное указание пользователя на сохранение данных, все объекты окружения должны быть сохранены автоматически. Кроме того, должна сохраняться и визуальная информация о состоянии окружения, такая, например, как позиция курсора, расположение и размер окна с тем, чтобы это состояние могло быть восстановлено при последующем сеансе работы пользователя.

При всех достоинствах объектного подхода к разработке интерфейса, его использование само по себе не гарантирует требуемого качества интерфейса. Для создания эффективного пользовательского интерфейса необходимо дополнить объектный подход тщательным проектированием всех компонентов интерфейса с ориентацией на потребности потенциального пользователя.

Первым шагом в объектно-ориентированном проектировании интерфейса должен быть анализ целей пользователей и особенностей выполняемых ими заданий. При проведении такого анализа следует определить основные компоненты или объекты, с которыми взаимодействует пользователь, а также характерные особенности объектов каждого типа. Необходимо также выявить перечень операций, выполняемых над объектами, их влияние на состояние и свойства объектов.

После завершения анализа можно переходить к описанию возможных способов взаимодействия пользователя с объектами различных типов. На этом шаге выбирается форма визуального представления объектов. При этом следует иметь в виду, что визуальный образ объекта в зависимости от ситуации может изменяться. Например, контейнер может быть представлен и в виде пиктограммы, и в виде окна, отображающего содержимое этого контейнера.

Следующим этапом проектирования *GUI* является компоновка и пространственное размещение на экране визуальных элементов интерфейса. Именно на этом этапе должны быть решены такие проблемы, как выбор цвета, размера и других атрибутов этих элементов, а также выбор средств и методов привлечения внимания пользователя к наиболее важной информации, отображаемой на экране.

Проектируя размещение информации на экране, необходимо предусмотреть возможность удобного доступа пользователя к средствам помощи, независимо от того, на каком шаге выполнения задания он находится, и какая именно информация представлена на экране.

1.  **Операции пересылки и создания объектов**

### ОПЕРАЦИИ ПЕРЕСЫЛКИ

К операциям пересылки относятся операции перемещения копирования и связывания объектов, а также их производные. Например, печать объекта является формой операции пересылки, поскольку она может быть реализована как копирование объекта на принтер.

Для выполнения любой операции пересылки должны быть указаны три параметра: пересылаемый объект, приемник (получатель) и способ пересылки (т.е. тип выполняемой операции). Эти параметры могут быть определены как явно, так и косвенно, в зависимости от используемой техники взаимодействия.

Тип операции пересылки определяется типом приемника. Поскольку пересылка может интерпретироваться по-разному, в некоторых случаях целесообразно назначить одну из операций в качестве предопределенной (выполняемой по умолчанию), а также ограничить перечень других допустимых операций пересылки, исходя из характеристик источника и приемника. Например, попытка переслать объект в контейнер может закончиться одним из следующих исходов:

-   Отклонением объекта
-   Приемом объекта
-   Включением некоторой части (подмножества) объекта или преобразованием его формата (например, включение только содержания объекта без его внешнего представления).

Большинство действий, связанных с пересылкой объектов, основаны на использовании одной из следующих трех операций.

Существуют два метода пересылки объектов: на основе команд и метод прямого манипулирования.

**ПЕРЕСЫЛКА НА ОСНОВЕ КОМАНД**

Для пересылки объектов используются команды *Вырезать (Cut), копировать (Copy)* и *вставить (Paste).* Эти команды обычно включаются в выпадающее меню *Правка (Edit)* и во всплывающее меню выбранного объекта. Соответствующие им кнопки могут быть вынесены на панель инструментов первичного окна приложения.

Чтобы переслать объект, пользователю необходимо:

1\. Выбрать объект, подлежащий пересылке.

2\. Выбрать команду *Вырезать* или *Копировать.*

3\. Указать позицию вставки.

4\. Выбрать команду *Вставить.*

Таблица 3

**Операции пересылки объектов**

| **Операция**         | **Описание**                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Переместить (*Move*) | Перемещает выбранный объект; поскольку перемещение не изменяет «подлинности» объекта, эту операцию не следует отождествлять с копированием или замещением оригинала.                                                                                                                                                                                                                                                                                          |
| Копировать (*Copy*)  | Создает копию объекта. Результирующий объект независим по отношению к своему оригиналу. Дублирование не всегда обеспечивает полную идентичность копии; некоторые ее свойства могут отличаться от свойств оригинала. Например, копирование объекта может привести к изменению имени или даты создания. Если имеются ограничения на копирование некоторых элементов объекта, то могут быть скопированы только те элементы, для которых ограничения отсутствуют. |
| Связать (*Link*)     | Создает связь между двумя объектами. Результатом обычно является объект, который обеспечивает доступ к оригиналу (ярлык).                                                                                                                                                                                                                                                                                                                                     |

Команда *Вырезать* удаляет выбранный объект и помещает его (или ссылку на него) в буфер обмена. Команда *Копировать* создает копию выбранного объекта (или ссылку на него) и помещает ее в буфер обмена.

При использовании команды *Вставить* по умолчанию предполагается, что пересылаемый объект сохранит все свойства оригинала, однако может быть использована и альтернативная форма этой команды для реализации других видов пересылки:

*Вставить [\<имя типа\>]* как *[\<имя типа\>* \|в *\<имя о6ъекта\>].*

Например, возможен такой вариант команды:

Вставить *[Ячейку]* как *[Слово]* (предполагается, что *Ячейка* и *Слово* являются конвертируемыми типами).

При выборе формата команды *Вставить* необходимо, в первую очередь, учитывать свойства приемника; для повышения гибкости работы пользователя ему может быть предоставлена возможность корректировки параметров команды в зависимости от особенностей пересылаемого объекта и сущности приемника.

Практика показывает, что для большинства приложений оказывается достаточным совместное использование стандартной команды *Вставить* и *Специальной вставки.*

Выполнение команды *Вставить* не должно влиять на содержимое буфера обмена. Это позволяет неоднократно повторно использовать данные, находящиеся в буфере. Вместе с тем, необходимо помнить, что последующее выполнение команд *Копировать* или *Вырезать* приводит к замене содержимого буфера обмена.

Ниже приведены общие форматы команды *Вставить* (табл. 4).

Таблица 4.

**Форматы команды Вставить**

| **Формат команды**                                                    | **Функция**                                                                                                                                                                                                                                                    |
|-----------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Вставить (*Paste*)                                                    | Вставляет объект, содержащийся в буфере обмена, сохраняя все свойства его оригинала                                                                                                                                                                            |
| Вставить [имя типа] (*Paste* [*type name*])                           | Вставляет объект, содержащийся в буфере обмена, как вложенный объект *OLE*; такой объект может быть активизирован непосредственно в позиции вставки                                                                                                            |
| Вставить [имя типа] как пиктограмму (*Paste* [*type name*] *as Icon*) | Вставляет объект, содержащийся в буфере обмена, как вложенный объект *OLE*; объект отображается как пиктограмма                                                                                                                                                |
| Вставить Ссылку (*Paste Link*)                                        | Создает ссылку на объект, который был скопирован в буфер обмена; в точку вставки помещается копия содержимого объекта, обладающая всеми его свойствами, однако при этом сохраняется связь с оригиналом, так что любое его изменение приводит к изменению копии |
| Вставить Ссылку на [имя объекта] (*Paste Link to* [*Object name*])    | Помещает в точку вставки изображение объекта, который был скопирован в буфер обмена, используя технологию *OLE*; любые изменения исходного объекта отражаются на его копии                                                                                     |
| Вставить ярлык (*Paste Shortcut*)                                     | Помещает в точку вставки ярлык объекта, который был скопирован в буфер обмена, используя технологию *OLE*; любые изменения исходного объекта отражаются на его копии                                                                                           |
| Специальная Вставка (*Paste Special*)                                 | Отображает на экране специальное диалоговое окно, позволяющее пользователю выбрать способ вставки объекта, содержащегося в буфере обмена                                                                                                                       |

Поскольку выполнение операций пересылки может привести к различным побочным эффектам, ниже описаны некоторые общие сценарии поведения приложения при их реализации:

• Если пользователь выполняет пересылку в приемник, для которого необходимо учитывать конкретную позицию вставки, следует заменить выбранный объект в приемнике переданными данными. Например, если выполняется вставка в текст (где положение выбранного фрагмента соответствует позиции вставки), пересылаемый объект заменяет текущий выбор. Если же в тексте-приемнике выбор не был сделан, точка вставки определяется текущим положением курсора.

• Для приемников, где нет явной точки вставки, следует поместить вставляемый объект в точку, определяемую текущим контекстом, и отобразить его как выбранный. В качестве контекстной информации можно, например, учитывать позицию указателя мыши, либо признак, по которому упорядочены в приемнике имеющиеся объекты (скажем, по алфавиту).

• Если новый объект автоматически связывается с текущим выбором в приемнике (например, табличные данные и отображающий их график), целесообразно добавить новый объект к текущему выбору.

**МЕТОД ПРЯМОГО МАНИПУЛИРОВАНИЯ**

Командный метод эффективен в тех случаях, когда операция пересылки требует от пользователя соответствующего управления источником и приемником. Тем не менее, при выполнении многих операций пересылки прямое манипулирование оказывается более естественным и быстрым методом. При использовании прямого манипулирования пользователь выбирает и перетаскивает объект в желаемую позицию, но поскольку этот метод требует определенных моторных навыков, следует избегать его использования в качестве единственного метода пересылки. В наиболее развитых интерфейсах поддерживаются оба метода: командный — для выполнения основных операций пересылки, а прямое манипулирование — как ускоренная техника работы пользователя.

Прямое манипулирование может применяться для любого визуального объекта. При этом как пересылаемый объект, так и приемник (например, окно или пиктограмма) не обязательно должны быть к настоящему времени активны. Например, пользователь может поместить объект в неактивное окно и в результате выполнения этой операции оно автоматически будет активизировано. Если неактивный объект не допускает пересылку с помощью прямого манипулирования, пользователь должен быть извещен об этом посредством соответствующей обратной связи.

Каким образом переданный объект интегрируется и отображается в приемнике, определяется контекстом приемника. Ранее уже отмечалось, что результатом пересылки может быть как точная копия оригинала, так и отдельные его компоненты или свойства, либо преобразованный объект. Например, приложение может содержать средства для копирования свойств объектов конкретного типа.

**Стандартная реализация техники drag-and-drop**

Стандартная реализация техники *drag-and-drop* основана на использовании левой кнопки мыши. Как именно будет проинтерпретировано приложением перетаскивание объекта, зависит от свойств приемника и от того, какая операция пересылки используется в качестве предопределенной. Как и в случае командного метода, результат операции определяется также свойствами перемещаемого объекта (в частности, перечнем разрешенных форматов объекта). Не рекомендуется использовать в качестве предопределенной операции такую, которая может привести к удалению или необратимому изменению объекта. Если же необходимость применения одной из таких операций обусловлена текущей ситуацией, следует вывести на экран сообщение пользователю с просьбой подтвердить намерения.

Используя технику *drag-and-drop,* пользователь может непосредственно пересылать объекты, как между окнами приложения, так и между окнами системных ресурсов, такими, например, как папки и принтеры.

Чаще всего в качестве предопределенной операции для *drag-and-drop* используется операция *Переместить (Move),* но вместо нее может быть определена любая другая операция пересылки, например, *Копировать* или *Связать,* или даже специализированная операция пересылки, такая, например, как *Копировать Свойства.*

**Нестандартная реализация техники drag-and-drop**

В основе нестандартной реализации техники *drag-and-drop* лежит использование правой кнопки мыши. Особенность данного подхода заключается в следующем. Когда пользователь щелкает ПКМ на объекте-приемнике (или на позиции, куда пересылается объект), вместо выполнения предопределенной операции открывается всплывающее меню для объекта-приемника. Это меню содержит набор команд пересылки, разрешенных для данной позиции, но с учетом особенностей объекта, подлежащего пересылке.

Тот факт, что команды всплывающего меню относятся к приемнику, а не к пересылаемому объекту, должен учитываться и в названиях этих команд. В частности, если пересылается содержимое объекта (данные), такими командами могут быть: *Переместить сюда (Move Here), Копировать сюда (Copy Here).* Если же приемник поддерживает пересылку только отдельных компонентов объекта, или требует его преобразования, названия команд должны отражать эту особенность приемника (например, *Копировать свойства сюда).*

Общий формат нестандартных команд пересылки выглядит следующим образом:

*[имя команды] [имя типа \\ имя объекта] Here* как *[имя типа].*

Ниже приведены пояснения к применению нестандартных команд пересылки (табл. 5).

Одна из перечисленных выше команд может быть использована в качестве предопределенной. Это должна быть команда, которая соответствует эффекту перетаскивания объекта при нажатой левой кнопке мыши.

Таблица 5.

**Нестандартные команды пересылки**

| **Команда**                                                                                                                                                    | **Функция**                                                                                                                                                                                                                                                                    |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Переместить сюда (*Move Here*)                                                                                                                                 | Пересылает в указанную позицию содержимое выбранного объекта (как данные)                                                                                                                                                                                                      |
| Копировать сюда (*Copy Here*)                                                                                                                                  | Создает в указанной позиции копию содержимого выбранного объекта                                                                                                                                                                                                               |
| Создать связь с приемником (*Link Here*)                                                                                                                       | Создает канал связи между выбранным объектом и позицией-приемником; содержимое выбранного объекта добавляется (возможно, после преобразования) к содержимому приемника, но сохраняется связь с источником, так что производимые в нем изменения отражаются в позиции-приемнике |
| Переместить [имя типа] сюда *(Move [type name] Here)* или Копировать [имя типа] сюда *(Copy [type name] Here)*                                                 | Перемещает или копирует выбранный объект как объект *OLE*, который отображается в своем исходном представлении и может быть активизирован непосредственно в позиции-приемнике                                                                                                  |
| Создать для [имя типа] Связь с приемником *(Link [type name] Here)*                                                                                            | Создает связанный объект *OLE*, отображаемый в приемнике как изображение выбранного объекта. Копия связывается с исходным объектом таким образом, что любые изменения в исходном объекте отражаются в позиции-приемнике                                                        |
| Переместить [имя типа] сюда как пиктограмму (*Move [type name] Here) as Icon* или Копировать [имя типа] сюда как пиктограмму *(Copy [type name] Here) as Icon* | Перемещает или копирует выбранный объект как объект *OLE* в указанную позицию и отображает его как пиктограмму                                                                                                                                                                 |
| Создать здесь ярлык (*Create Shortcut Here*)                                                                                                                   | Создает объект *OLE*, связанный с выбранным объектом; новый объект отображается как ярлык; любые изменения исходного объекта отражаются в позиции-приемнике                                                                                                                    |

Если пользователь, начав перетаскивать объект, возвращает его в исходную позицию, это следует интерпретировать как отмену операции пересылки. Тот же эффект обеспечивает нажатие пользователем клавиши \<*Esc*\> в течение выполнения операции пересылки. Кроме того, целесообразно включить команду *Отменить* во всплывающее меню, используемое при нестандартной технике пересылки.

Поскольку при выполнении операций пересылки совмещается выбор объекта и его перемещение, необходимо установить соглашение, позволяющее пользователю различать эти операции. Используемое вашим приложением соглашение зависит от свойств объектов приложения; в некоторых случаях могут быть предусмотрены различные средства взаимодействия пользователя с объектом при выполнении выбора и пересылки. Наиболее общий подход основан на том, что признаком выполняемой операции является исходная позиция указателя мыши. Если указатель расположен в пределах существующего выбора, то к выбранному объекту применяется о; если же в момент нажатия ЛКМ указатель находится вне области выбора, то его последующее перемещение интерпретируется как операция выбора.

**ОСОБЕННОСТИ РЕАЛИЗАЦИИ ПРОКРУТКИ ПРИ ВЫПОЛНЕНИИ ОПЕРАЦИЙ ПЕРЕСЫЛКИ**

Когда пользователь перетаскивает объект внутри какой-либо перемещаемой области (такой как окно или список) в другую позицию, это может привести к тому, что объект окажется за пределами видимости. В этом случае целесообразно использовать возможность **автоматической прокрутки** области (которая известна также как *авто скроллинг).*

Вместе с тем, при выполнении операций пересылки путем прямого манипулирования пользователю необходимо «вытащить» объект из одного окна и поместить в другое. При этом авто скроллинг не только не нужен, он просто помешает пользователю выполнить требуемую операцию.

Чтобы различать две эти ситуации, можно анализировать скорость перемещения объекта. Например, если пользователь тащит объект медленно к краю перемещаемой области, используется авто скроллинг; если же объект перемещается быстро, выполняется операция пересылки.

Для реализации указанного подхода требуется запомнить позицию указателя в начальный момент перемещения мыши и затем регистрировать его положение через равные промежутки времени (рекомендуемый интервал — 100 миллисекунд). Если же приложение поддерживает пересылку на основе *OLE*, то замеры через равные промежутки времени будут некорректны. В этом случае следует запоминать каждое новое положение указателя в специальном массиве, достаточно большом, чтобы хранить три последних значения, заменяя самое старое из них текущим. При вычислении скорости указателя используются координаты, по крайней мере, двух последних его позиций.

Чтобы рассчитать скорость перемещения, необходимо вычислить расстояние между соседними позициями указателя и разделить его на величину интервала времени между моментами регистрации. Расстояние вычисляется как модуль разности между координатами *х* и *у* двух соседних позиций:

Полученное значение следует умножить на 1024 и разделить на интервал времени.

Следует также определить **горячую зону** авто скроллинга вдоль границ перемещаемой области и величину задержки прокрутки. Как правило, ширина горячей зоны устанавливается равной удвоенной ширине вертикальной полосы прокрутки или удвоенной высоте горизонтальной полосы прокрутки.

Итак, автоматическая прокрутка должна выполняться при одновременном соблюдении трех условий:

-   в процессе перемещения объекта указатель оказался в горячей зоне окна;
-   скорость перемещения объекта ниже определенной (пороговой) скорости;
-   видимая область окна может быть перемещена в соответствующем направлении.

Рекомендуемая пороговая скорость — 20 пикселов в секунду.

Величина прокрутки зависит от типа перемещаемой информации и допустимого расстояния прокрутки. Например, при работе с текстом вертикальная прокрутка обычно выполняется построчно. Целесообразно также согласовать дискретность авто скроллинга с дискретностью перемещения, которая предусмотрена для полос прокрутки.

Чтобы обеспечить непрерывную прокрутку, необходимо выполнить следующие действия. Во-первых, выбрать частоту прокрутки, например, четыре строки в секунду. Во-вторых, после начала авто скроллинга следует установить таймер на определенный интервал (например, на 100 миллисекунд). Когда установленный интервал истечет, определите величину прокрутки за это время. Если интенсивность прокрутки превышает заданную частоту, переместите видимую область еще на один шаг. Если нет, восстановите таймер и повторите описанную последовательность действий при следующей инициализации авто скроллинга.

**ОБРАТНАЯ СВЯЗЬ ПРИ ВЫПОЛНЕНИИ ОПЕРАЦИЙ ПЕРЕСЫЛКИ**

Поскольку пересылка объектов является одним из наиболее распространенных действий пользователя, наличие соответствующей обратной связи является важным показателем качества интерфейса создаваемого приложения.

**РЕАЛИЗАЦИЯ ОБРАТНОЙ СВЯЗИ ПРИ ПЕРЕСЫЛКЕ НА ОСНОВЕ КОМАНД.**

Если при пересылке объекта пользователь выбирает команду *Вырезать,* следует визуально удалить выбранный объект. Если в силу каких-либо причин это нецелесообразно, можно отобразить выбранный объект специальным образом, чтобы сообщить пользователю, что команда *Вырезать* выполнена, но пересылка объекта еще не закончена.

Необходимо также восстанавливать визуальное состояние объекта, если пользователь выбирает команду *Вырезать* или *Копировать* для другого объекта прежде, чем выполнить команду *Вставить* для первоначально выбранного объекта.

Команда *Копировать* не требует специальной обратной связи. Выполнение команды *Вставить* также не требует никакой дополнительной обратной связи, кроме как отображение переданного объекта в новой позиции. Тем не менее, если при выполнении команды *Вырезать* образ объекта в исходной позиции был не удален, а заменен альтернативным представлением, необходимо его теперь «окончательно» удалить.

**СПЕЦИАЛЬНЫЕ КОМАНДЫ ПЕРЕСЫЛКИ**

При выполнении некоторых заданий определенная комбинация операций пересылки может использоваться настолько часто, что ее удобнее заменить соответствующей дополнительной специализированной командой. Примером такой комбинации является дублирование существующего объекта, выполняемое с помощью двух операций — *Копировать* и *Вставить.* Вместо них может быть использована специальная команда *Дублировать.* Ниже приведены некоторые наиболее распространенные специализированные команды пересылки (табл. 6).

На первый взгляд, команды *Удалить и Очистить* дают один и тот же эффект. Тем не менее, каждая из них действительно более корректно работает по своему прямому назначению: *Удалить —* при удалении одного (выбранного) объекта, а *Очистить —* при очистке контейнера.

Таблица 6.

**Специализированные команды пересылки**

| **Команда**               | **Функция**                                                                                                                 |
|---------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| Удалить (*Delete*)        | Удаляет объект из содержащего его контейнера. Если объект — файл, то он пересылается в Корзину                              |
| Очистить (*Clear*)        | Удаляет содержимое контейнера                                                                                               |
| Дублировать (*Duplicate*) | Создает одну копию выбранного объекта                                                                                       |
| Печать (*Print*)          | Печатает выбранный объект на принтере, используемом по умолчанию                                                            |
| Отправить (*Send To*)     | Отображает список возможных направлений пересылки выбранного объекта и пересылает его в соответствии с выбором пользователя |

**КЛАВИШИ-АКСЕЛЕРАТОРЫ ДЛЯ ОПЕРАЦИЙ ПЕРЕСЫЛКИ**

Перечисленные ниже комбинации клавиш обеспечивают ускоренный доступ к операциям пересылки (табл. 7).

Таблица 7.

**Клавиши-акселераторы для операций пересылки**

| **Комбинация клавиш**            | **Функция**                                                                                                                                              |
|----------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| *CTRL + X*                       | Выполняет команду Вырезать                                                                                                                               |
| *CTRL + C*                       | Выполняет команду Копировать                                                                                                                             |
| *CTRL + V*                       | Выполняет команду Вставить                                                                                                                               |
| *СТRL* + \<перемещение объекта\> | Заменяет предопределенную операцию пересылки операцией Копировать (если приемник ее поддерживает); модификатор может использоваться с любой кнопкой мыши |
| *ESC*                            | Отменяет выполнение операции пересылки (если она еще не закончена)                                                                                       |

Из-за широкого применения приведенных комбинаций клавиш для всего интерфейса, не рекомендуется использовать их в других целях.

### ОПЕРАЦИИ СОЗДАНИЯ НОВЫХ ОБЪЕКТОВ

Возможность создания новых объектов пользователем предусмотрена в подавляющем большинстве приложений. Хотя каждое из них ориентировано на создание объектов определенного типа, разработчик приложения должен, как правило, воздерживаться от применения для этих целей каких-то специфических средств. Обычно создание нового объекта основано на использовании некоторого предопределенного объекта (шаблона) или спецификации и может быть реализовано несколькими способами, поддерживаемыми стандартными средствами пользовательского интерфейса.

-   **Команда Копировать (Copy)**

Получение копии существующего объекта является основным способом создания новых объектов. Объекты-копии могут модифицироваться и обычно используются в качестве прототипов для создания новых объектов, обладающих иными свойствами по сравнению с объектом-оригиналом. Технология создания новых объектов указанным способом определяется соглашениями по использованию one-раций пересылки, рассмотренными выше.

-   **Команда Создать (New)**

Команда *Создать (New)* облегчает создание новых объектов. Она обеспечивает автоматическое создание нового экземпляра объекта определенного типа и может рассматриваться как комбинация команд *Копировать (Copy)* и *Вставить (Paste).*

-   **Команда Поместить (Insert)**

Команда *Поместить (Insert)* работает аналогично команде *Создать (New),* за исключением того, что она применяется к контейнеру для создания нового объекта (обычно определенного типа) внутри этого контейнера. Используя различные форматы команды *Поместить,* можно предоставить пользователю возможность включать в контейнер объекты различных типов. Если создаваемое приложение поддерживает технологию *OLE*, с помощью команды *Поместить* может быть реализовано создание широкого класса объектов. Кроме того, объекты, поддерживаемые вашим приложением, могут включаться в файлы данных, созданные другими приложениями *OLE.*

**Использование элементов управления**

С целью автоматического создания новых объектов могут использоваться элементы управления. Например, в графических приложениях часто используются кнопки, соответствующие различным инструментальным средствам или способам создания новых объектов, таких как линия определенной формы или геометрическая фигура. Кнопки могут также использоваться для внедрения объектов по технологии *OLE.*

**Использование шаблонов**

**Шаблон** является специальным объектом, который автоматизирует создание нового объекта. Чтобы пользователю было понятно его предназначение, пиктограмма шаблона должна содержать небольшой рисунок, отражающий тип создаваемых с его помощью объектов, как показано на рис. 1.

![](/static/lection-images/fc27e21958cdf8252666774f83a1e24f.png)Рис. 1. Пример пиктограммы шаблона

В качестве предопределенной операции для объекта *Шаблон* используется команда *Создать;* она инициирует процесс создания объекта, который может выполняться как полностью автоматически, так и в режиме диалога с пользователем. Вновь созданный объект должен находиться в той же позиции, где находился шаблон. Если текущий контекст не позволяет это сделать, объект следует установить в другой доступной пользователю позиции, например, на Рабочем столе. Размещение нового объекта может также быть указано пользователем в процессе диалога при создании объекта; в этом случае по завершении создания объекта следует вывести на экран сообщение, информирующее пользователя о местоположении созданного объекта.

1.  **Проектирование окон и пиктограмм**

## **ПРОЕКТИРОВАНИЕ ПИКТОГРАММ**

Все пиктограммы, используемые в приложении, следует разрабатывать как единый набор; при этом должна обеспечиваться их согласованность и друг с другом, и с заданиями пользователя. Если первоначальный вариант не удовлетворяет потенциального пользователя, нельзя жалеть времени на внесение изменений.

Каждая пиктограмма должна быть реализована в трех стандартных форматах: 16х16 пикселов (для 16 цветов), 32х32 пиксела (также для 16 цветов) и 48х48 пикселов (для 256 цветов). Хотя для меньших размеров также может быть использована большая глубина цвета, это требует увеличения памяти для хранения пиктограмм и не может быть реализовано на всех конфигурациях компьютера.

Система автоматически формирует цветовую схему пиктограммы для монохромных конфигураций. Тем не менее, целесообразно заранее оценить качество зрительного восприятия разработанных пиктограмм в монохромном режиме. Если результат окажется неудовлетворительным, следует создать собственные монохромные варианты пиктограмм.

Пиктограммы необходимо разрабатывать не только для исполняемого файла приложения, но также для всех типов файлов данных, поддерживаемых вашим приложением.

При этом пиктограммы для файлов данных (или документов) должны отличаться от пиктограммы приложения. Как правило, они могут содержать некоторый общий элемент, однако основное содержание рисунка пиктограмм файлов данных должно отражать сущность хранимой в них информации.

Все созданные пиктограммы должны быть зарегистрированы в системном реестре. Если какая-либо из пиктограмм не будет зарегистрирована, система автоматически использует вместо нее основную пиктограмму приложения. Тем не менее, вряд ли такая замена будет удачнее того, что мог бы предложить сам разработчик.

В основу рисунка, отображаемого на пиктограмме, должен быть положен образ объекта реального мира, точнее, те его детали, которые действительно необходимы для однозначного восприятия объекта пользователем. Где это возможно, лучше использовать трехмерное изображение и светотень, чтобы лучше передать образы реального мира.

Подводя итог обсуждению стиля создаваемых пиктограмм, можно сказать, что выводимое на них изображение должно вызывать у потенциального пользователя вполне определенную предсказуемую ассоциацию с объектами реального мира.

**ПЕРВИЧНЫЕ ОКНА**

Поскольку окна предоставляют доступ к различным видам информации (текстовой, графической), они классифицируются согласно их основному предназначению. Взаимодействие с объектами обычно реализуется с помощью так называемого **первичного окна,** в котором происходит первоначальный просмотр и редактирование данных. Кроме того, могут использоваться дополнительные **(вторичные)** окна, которые позволяют устанавливать дополнительные параметры обработки, или обеспечивают доступ к более специфическим деталям взаимодействия с объектами, включенными в первичное окно.

### СТРУКТУРА ПЕРВИЧНОГО ОКНА

Типовое первичное окно состоит из **рамки** (или границы), которая определяет размеры окна, и **заголовка окна,** который идентифицирует информацию, представленную в окне. Если объем выводимой информации превышает текущий размер окна, оно дополняется **полосами прокрутки.** Окно может также содержать другие элементы интерфейса (меню, панель инструментов, строку состояния).

Внешний вид рамки окна определяется типом окна. Изменяемое окно имеет четкую границу, которая обеспечивает управление размерами на основе прямого манипулирования. Если окно не может изменять размеры, граница «сливается» с краем окна.

В верхней части окна находится заголовок окна. Он выводится в так называемой **полосе заголовка,** которая занимает всю ширину окна. Полоса заголовка служит также в качестве опорной точки для перемещения окна и для отображения свернутого окна. Кроме того, она используется в качестве средства доступа к командам управления окном. В частности, щелчок правой кнопкой мыши в полосе заголовка приводит к появлению всплывающего меню для данного окна.

Первичное окно содержит также уменьшенную копию пиктограммы объекта или приложения, к которому оно относится. Она выводится в верхнем левом углу окна (в полосе заголовка). Если окно относится к какой-либо компоненте приложения, которая не создает свои собственные файлы данных, то рекомендуется в качестве такой пиктограммы использовать пиктограмму самого приложения.

Если приложение обеспечивает работу с различными форматами документов или файлов, и данное окно отображает один из этих файлов, используйте в полосе заголовка пиктограмму.

Если приложение использует многодокументный интерфейс (*MDI*), поместите пиктограмму приложения в полосе заголовка родительского окна, а в полосе заголовка дочернего окна — пиктограмму, которая отражает конкретный тип файла данных приложения.

Когда пользователь разворачивает дочернее окно, и полоса заголовка обоих окон объединяется, отобразите пиктограмму заголовка дочернего окна в полосе меню родительского окна. Если открыто несколько дочерних окон, то в указанной позиции следует отобразить только пиктограмму активного (самого верхнего) дочернего окна.

Полоса заголовка окна используется также в качестве интерактивного элемента для вызова всплывающего меню окна: когда пользователь щелкает на пиктограмме заголовка окна ПКМ, на экране появляется всплывающее меню для соответствующего объекта. Обычно такое меню содержит типовой набор команд (открыть/закрыть окно, изменить размер окна и т.п.). Рекомендуется также поддерживать использование двойного щелчка ЛКМ на пиктограмме окна в качестве ускоренного способа закрытия окна.

Заголовок окна идентифицирует объект, отображаемый в окне. Он также должен быть согласован с пиктограммой этого объекта, используемой в файловой системе. Например, если пользователь открывает файл данных с названием *Мой_Документ,* то в полосе заголовка окна должна быть помещена пиктограмма для этого типа документа, сопровождающаяся именем файла данных. Дополнительно можно также указать имя используемого приложения.

Для приложения, использующего *MDI*, его имя отображается в родительском окне, а в дочернем окне — имя данных.

Если пользователь непосредственно открывает приложение, которое отображает новый *файл* данных, укажите его имя в заголовке окна, даже если пользователь еще не сохранял файл. Используйте для него какое-либо общее имя, отражающее тип данных, например *Документ(п), Лист(п), Диаграмма(п),* где *n —* порядковый номер файла этого типа. Убедитесь, что предлагаемое имя не будет конфликтовать с существующими именами в текущем каталоге. Это имя может быть использовано как предлагаемое по умолчанию при сохранении файла. В некоторых случаях для нового файла удобнее использовать более универсальное название — *Безымянный (Untitled).*

Следуйте этому же соглашению, если ваше приложение содержит команду *Создать,* которая создает новые файлы. Избегайте указания имени пользователя для идентификации окна. Вместо этого вы можете открыть диалоговую панель *Сохранить как..,* которая позволяет пользователю подтверждать или изменять предлагаемое вами имя, когда они сохраняют или закрывают файл, либо пытаются создать новый файл.

Отображайте имя файла в заголовке окна точно в таком же виде, в каком оно представлено в файловой системе, в том числе с учетом использования символов верхнего и нижнего регистров.

Если имя отображаемого в окне объекта изменилось (например, после того как пользователь отредактирует его), необходимо отразить это изменение в заголовке окна. Всегда пытайтесь поддержать явную ассоциацию между объектом и открытым окном.

Когда ширина окна не позволяет отображать полностью название объекта, можно его сократить, однако это следует делать таким образом, чтобы сохранить существенную информацию, которая позволяет пользователю быстро идентифицировать окно.

Избегайте включения в полосу заголовка рисунков либо дополнительных элементов управления. Такие дополнительные элементы могут затруднить восприятие имени окна, особенно в тех случаях, когда размер заголовка изменяется вместе с изменением размера окна. Кроме того, система использует эту область для отображения специальных средств управления. Например, в некоторых локализованных версиях Windows в полосе заголовка выводится информация или элементы управления, связанные с использованием определенных языков.

Вместе с тем, рекомендуется включать в полосу заголовка кнопки, предназначенные для управления размерами и состоянием первичного окна. В табл. 8. приведено описание стандартных кнопок управления окном.

Таблица 8.

**Кнопки управления первичным окном**

| **Кнопка**                                      | **Команда**              | **Выполняемые действия**                               |
|-------------------------------------------------|--------------------------|--------------------------------------------------------|
| ![](/static/lection-images/2a1fbda928a533a8598551b325b45d70.png) | Закрыть (*Close*)        | Закрывает окно                                         |
| ![](/static/lection-images/81f5ca97aa8dd45c06e563bf6879be19.png) | Свернуть (*Minimize*)    | Сворачивает окно                                       |
| ![](/static/lection-images/164b964b20a46a5d9b4f4ac7c1eaadde.png) | Развернуть (*Maximize*)  | Устанавливает максимальный (полноэкранный) размер окна |
| ![](/static/lection-images/f0ad881c8b2663f06c075b0eced8a588.png) | Восстановить (*Restore*) | Устанавливает номинальный размер окна                  |

В данном случае под **номинальным** понимается размер, который был установлен пользователем перед выполнением команд *Закрыть* или *Свернуть*.

Система не поддерживает для первичных окон использование кнопки вызова контекстно-зависимой справочной информации (*Help*), доступной во вторичных окнах. Если вы считаете, что ее наличие необходимо, можно включить кнопку *Help* в состав панели инструментов первичного окна. С другой стороны, не рекомендуется вставлять указанные выше кнопки управления *(Развернуть, Свернуть, Восстановить)* в полосу заголовка вторичных окон, поскольку соответствующие им команды не поддерживаются системой для этих окон.

Отображая кнопки управления первичного окна, используйте следующие руководящие принципы:

-   Если команда не поддерживается окном, не отображайте соответствующую ей кнопку.
-   Кнопка закрытия окна всегда должна быть самой правой кнопкой. Оставляйте промежуток между ней и всеми другими кнопками.
-   Кнопка *Свернуть* должна предшествовать кнопке *Развернуть.*
-   Кнопка *Восстановить* всегда заменяет кнопку *Развернуть* или кнопку *Свернуть* после выполнения соответствующей команды.

Когда пользователь открывает новое первичное окно, для него на Панели задач создается **кнопка входа.** Эта кнопка предоставляет пользователю доступ к командам соответствующего окна и обеспечивает переключение на это окно после работы с каким-либо другим из открытых окон. Размер кнопок входа на Панели задач регулируется автоматически таким образом, чтобы разместить на ней по возможности кнопки для всех открытых окон. Если при этом размер кнопки оказывается слишком мал, чтобы уместить полное название окна, для нее автоматически создается всплывающая подсказка, которая отображает полное название первичного окна.

Когда окно сворачивается, его кнопка входа по-прежнему остается на Панели задач; она удаляется только в том случае, если пользователь закрывает окно.

Кнопки входа могут также использоваться в качестве объекта-приемника при выполнении операций пересылки. Когда пользователь помещает перетаскиваемый объект над кнопкой входа, система активизирует связанное с этой кнопкой окно, позволяя пользователю поместить объект в окно.

### ОСНОВНЫЕ ОПЕРАЦИИ С ОКНАМИ

К основным операциям с окнами относятся: изменение состояния (активно/ неактивно), открытие и закрытие, перемещение, изменение размера, прокрутка, разбиение.

**Изменение состояния окна**

Если даже система поддерживает многооконность, пользователь, тем не менее, обычно выполняет некоторую последовательность действий в пределах одного окна. Это окно называется **активным.** Активное окно, как правило, является окном самого верхнего уровня (т.е. расположено «поверх» других открытых окон). Визуально оно отличается своим заголовком, который подсвечивается специальным «активным» цветом. В каждый момент времени может быть активным только одно окно. Хотя Другие окна могут относиться к активным (выполняющимся) процессам, но только одно — активное — окно способно воспринимать информацию (команды или данные), вводимую пользователем. Заголовок неактивного окна отображается системным «неактивным» цветом (при необходимости приложение может запросить установленные системные цвета заголовка для активного и неактивного окна).

Пользователь активизирует требуемое первичное окно, переключаясь на него; это автоматически приводит к изменению состояния всех других первичных окон. Для того, чтобы активизировать окно с помощью мыши, пользователю достаточно нажать любую ее клавишу, поместив указатель в произвольную точку окна, включая его контур. Если окно находится в свернутом виде, то для его активизации следует щелкнуть мышью на полосе заголовка окна.

При работе с клавиатурой для переключения между первичными окнами используется комбинация клавиш *\<Alt\>+\<Tab\>.* Комбинация клавиш *\<Shift\>+\<Alt\>+\<Tab\>* также обеспечивает переключение между окнами, но в обратном порядке (для переключения между окнами система также поддерживает комбинацию *\<Alt\>+\<Esc\>).* Повторная активизация окна не должна влиять на любой предшествующий выбор в пределах этого окна; другими словами, при активизации окна область выбора и фокус ввода восстанавливаются в том же виде, какой они имели в предыдущем активном состоянии. Кроме того, при повторной активизации первичного окна само окно и все связанные с ним вторичные окна становятся окнами верхнего уровня, причем восстанавливается их взаимное расположение.

Когда окно становится неактивным, уберите визуальное отображение выбора в пределах этого окна, чтобы явно указать, какое именно окно получает данные, вводимые с клавиатуры. Исключением является выполнение операций прямого манипулирования (например, копирования объекта из одного окна в другое). В этом случае можно восстановить визуальное отображение выбора в окне-получателе на то время, пока указатель находится над окном (т.е. в течение выполнения операции прямого манипулирования).

Поскольку разрабатываемое приложение должно, как правило, выполняться на различных модификациях аппаратных средств, нельзя делать его зависящим от конкретных технических характеристик этих средств (например, от разрешающей способности монитора). При использовании стандартного системного интерфейса система автоматически позиционирует окна приложения в соответствии с характеристиками используемого монитора.

1.  **Проектирование элементов управления: меню, кнопки, списки, текстовые области, панели инструментов, другие элементы**

Под элементами управления обычно понимаются компоненты графического интерфейса, которые предоставляют пользователю возможность изменять содержимое или форму представления отображаемой информации, а также управлять работой приложения. К элементам управления относятся, в частности, списки, полосы прокрутки, кнопки и т.д.

Каждый элемент управления имеет уникальный образ и обеспечивает определенную форму взаимодействия пользователя с приложением. Система также поддерживает возможность создания собственных элементов управления. Определяя такие элементы, следует учитывать существующие системные соглашения, принятые для стандартных элементов управления.

Подобно большинству элементов интерфейса, элементы управления обеспечивают обратную связь с пользователем, изменяя определенным образом свой внешний вид в тех случаях, когда они активизированы. Например, когда пользователь взаимодействует с элементами управления, использующими мышь, каждый из них «реагирует» на выбор при нажатии кнопки мыши, но не активизируется до тех пор, пока пользователь не отпустит кнопку. Если пользователь перемещает указатель за пределы элемента управления при нажатой кнопке мыши, он перестает воспринимать входное воздействие. Если пользователь возвращается на элемент управления, тот снова переходит в активное состояние. **Горячая зона,** которая определяет, будет ли реагировать элемент управления на указатель, зависит от типа элемента. Для некоторых элементов управления, таких, например, как кнопки, горячая зона совпадает с видимой границей элемента. Для других горячая зона может включать графический символ элемента управления и относящуюся к нему текстовую область (например, это справедливо для флажков и переключателей).

Для большинства элементов управления система обеспечивает вывод текстовой подсказки. Поскольку подсказка помогает пользователю определить предназначение данного элемента управления, всегда идентифицируйте элемент, с которым в данный момент взаимодействует пользователь. Если элемент не имеет подсказки, ее можно реализовать в виде статической текстовой области или в виде всплывающей подсказки (tooltip).

Поскольку некоторые из элементов управления могут обеспечивать какие-либо специфические способы взаимодействия пользователя с приложением, целесообразно создать для них всплывающее меню. Оно может оказаться эффективным средством в тех случаях, когда элемент управления используется либо для передачи некоторой величины, имеющей несколько возможных значений, либо для доступа к контекстно-зависимой справочной информации. Для таких меню должны соблюдаться стандартные правила создания всплывающих меню, приведенные ниже, за исключением того, что в данном случае щелчок ЛКМ на выбранном пункте не запускает действие, связываемое с элементом управления. Другими словами, всплывающее меню элемента управления позволяет пользователю определить, какие действия он реализует в текущей ситуации, но не позволяет непосредственно выполнить эти действия.

Несмотря на то, что меню по своему предназначению имеет полное право входить в число элементов управления, практически во всех изданиях, посвященных инструментальным средствам создания приложений, его рассматривают как самостоятельную компоненту интерфейса. Объясняется это отличием программной реализации меню от других элементов управления (которые в англоязычной литературе именуются **controls).** Тем не менее на этапе проектирования пользовательского интерфейса многие вопросы, относящиеся к использованию меню, должны решаться совместно с проектированием других элементов управления. Именно в силу указанного обстоятельства технология проектирования и использования меню как средства взаимодействия пользователя с приложением рассматривается в данной главе.

-   **МЕНЮ**

**Меню** содержит перечень команд, имеющихся в распоряжении пользователя при выполнении определенного шага задания или задания в целом. Меню предоставляет пользователю возможность выбора необходимого средства решения задачи, не требуя от него запоминания имен команд и их синтаксиса.

Существуют различные типы меню, в том числе выпадающие, всплывающие и каскадные (иерархические) меню. Применение каждого из них имеет свои особенности, которые рассматриваются ниже.

### ГЛАВНОЕ МЕНЮ ОКНА И ВЫПАДАЮЩИЕ МЕНЮ

Одна из наиболее распространенных форм меню - линейная последовательность команд (или разделов). Именно в таком виде выполнено **главное меню** окна, расположенное непосредственно под полосой заголовка первичного окна. В связи с этим главное меню называют также **полосой меню.**

Полоса меню содержит названия пунктов меню, каждый из которых предоставляет доступ к выпадающему меню.

Содержание главного меню и связанных с ним выпадающих меню определяется функциональным предназначением вашего приложения и контекстом выполняемого пользователем задания. Вы можете обеспечить выбор пользователем дополнительной конфигурации окна, при которой главное меню не отображается. В этом случае необходимо предусмотреть элементы управления, обеспечивающие доступ к тем же функциям приложения, что и главное меню.

### ПУНКТЫ МЕНЮ

Каждый пункт меню соответствует определенному действию, которое может выполнить пользователь в данной ситуации. Пункты меню могут быть представлены в текстовой или в графической форме (Например, в виде пиктограмм), либо как комбинация графики и текста. При использовании графического интерфейса формат пункта меню должен обеспечивать визуальное отображение выбора пользователя.

Если меню содержит большое количество пунктов, и они могут быть сгруппированы по некоторому признаку, целесообразно визуально разделить такие группы. В качестве стандартного разделителя используется горизонтальная прямая линия. Не рекомендуется использовать в качестве разделителей сами пункты меню, либо текстовые подзаголовки, которые могут быть восприняты пользователями как название пункта меню.

Всегда обеспечивайте пользователя визуальным указанием тех пунктов, которые в данной ситуации не доступны. Обычно такие пункты меню либо «обесцвечиваются», либо вообще не отображаются на панели, причем первый способ является более предпочтительным с точки зрения обеспечения обратной связи с пользователем. Из этих же соображений целесообразно сохранить для недоступных пунктов возможность выдачи подсказки. В частности, если окно содержит строку состояния, то в ней можно отобразить сообщение, указывающее, что собой представляет данная команда, и почему она недоступна.

Если в некоторой ситуации ни один из пунктов меню не является доступным, сделайте недоступным данное меню в целом.

Система обеспечивает стандартный способ отображения недоступных пунктов меню. Если вы хотите использовать собственный способ визуализации таких пунктов, помните о том, что он должен быть одинаков для всех однотипных меню создаваемого приложения.

-   **КНОПКИ**

Кнопки — это элементы интерфейса, которые служат для инициирования каких-либо действий или для изменения свойств объектов. Существует три основных типа кнопок: кнопки управления *(Command Buttons),* кнопки установки параметров *(Option Buttons, Radio buttons),* или переключатели, и кнопки независимого выбора, или флажки (*Check boxes).*

### КНОПКИ УПРАВЛЕНИЯ

Кнопка управления, обычно именуемая в русскоязычных изданиях просто *кнопкой,* предназначена для запуска связанной с ней команды или операции; такая кнопка имеет, как правило, прямоугольную форму и снабжается поясняющей меткой, в качестве которой может использоваться текст, графический символ, либо то и другое, как показано на рис. 2.

![](/static/lection-images/b0b27ecc79f2a55f597753544aefc1c7.jpeg)Рис. 2. Примеры реализации кнопок

Когда пользователь выбирает кнопку с помощью мыши (щелкает на ней ЛКМ), выполняется команда, связанная с кнопкой. Если пользователь нажимает кнопку мыши (не отпуская ее), фокус ввода переходит на кнопку; при этом изменяется состояние кнопки (она отображается как «нажатая»). При перемещении указателя за пределы кнопки она возвращается в свое исходное состояние. Перемещение указателя обратно на кнопку вновь переводит ее в «нажатое» состояние.

Если пользователь отпускает кнопку мыши, когда указатель находится над кнопкой, выполняется связанная с ней команда; если же указатель расположен за пределами кнопки, фокус ввода «снимается» с кнопки без выполнения команды.

Вы можете определить для кнопок клавиши доступа и клавиши-акселераторы. Кроме того, целесообразно обеспечить пользователю возможность навигации между кнопками с помощью клавиатуры. Для этого рекомендуется использовать клавишу *\<Таb\>* в сочетании с клавишами управления курсором. Клавиша \<Spacebar\> по умолчанию используется для активизации кнопки при установке на нее фокуса ввода.

Результат команды, выполняемой при «нажатии» кнопки, проявляется немедленно и непосредственно влияет на текущую ситуацию. Например, при «нажатии» кнопки, расположенной на панели инструментов приложения, тут же выполняется связанное с ней действие; «нажатие» кнопки, отображенной во вторичном окне, обеспечивает прием вводимых данных и, возможно, закрытие окна.

Как было указано выше, кнопка управления снабжается метком, обозначающей связанное с ней действие. Если в качестве метки используется текст, то он должен отвечать тем же требованиям, которые были рассмотрены ранее применительно к пунктам меню. Если в какой-либо ситуации связанная с кнопкой команда является недоступной, то это должно быть отображено визуально (как правило, и этом случае обесцвечивается метка кнопки).

Для кнопок, связанных с командами, которые требуют ввода дополнительной информации, в качестве соответствующего визуального признака используется эллипсис (...). Для некоторых кнопок при их «нажатии» может выводиться окно сообщения, но это не означает, что метка такой кнопки должна содержать эллипсис.

Кнопки могут также использоваться для расширения вторичного окна с целью отображения в нем дополнительных параметров; такие кнопки называются *кнопками развертывания* и представляют собой частный случай применения кнопок для выполнения специфической функции. Если кнопка используется с указанной целью, ее метка должна содержать пару символов \>\> .

В некоторых случаях кнопка может представлять объект и связанное с ним по умолчанию действие. Например, кнопки входа, отображаемые на Панели задач, представляют первичные окна объектов и команду *Восстановить.* Когда пользователь щелкает на такой кнопке ЛКМ, для выбранного объекта выполняется указанная команда; щелчок на кнопке Входа ПКM приводит к появлению всплывающего меню для соответствующего объекта.

Кроме того, кнопки могут также использоваться для *выбора* режима работы или значения некоторой величины; в этом случае их применение аналогично применению кнопок двух других типов — переключателей и флажков. Если кнопка используется подобным образом, то для визуального представления состояния выбранной кнопки применяется изображение, несколько отличающееся от стандартного изображения «нажатой» кнопки. Изображения кнопок, рекомендуемые для визуального представления их возможных состоянии, приведены в табл. 9.

Таблица 9.

**Рекомендуемые изображения кнопок**

| **Изображение**                                   | Состояние кнопки                                                      |
|---------------------------------------------------|-----------------------------------------------------------------------|
| ![](/static/lection-images/69a99243cf8dda555d4837df57f44070.jpeg)  | Нормальное состояние (кнопка не выбрана)                              |
| ![](/static/lection-images/388feda9448bff85f7fced40ecdcd0d1.jpeg)  | Кнопка “нажата”                                                       |
| ![](/static/lection-images/083bcd54100db99bc3150e6fbc1e113e.jpeg)  | Кнопка используется как переключатель находится в состоянии "выбрана" |
| ![](/static/lection-images/e72f9bb41dfd3944a060ade4ac56fb9e.jpeg)  | Кнопка недоступна                                                     |
| ![](/static/lection-images/d59f876537f753bf928fd73eac60392f.jpeg)  | Кнопка используется как переключатель, но в данный момент не доступна |
| ![](/static/lection-images/e165641cdc7ecee555cb036f6b292d58.jpeg)  | Кнопка находится в состоянии "не определено"                          |
| ![](/static/lection-images/88b32ffb5f945ccec5159c82a0872985.jpeg)  | Кнопка находится в фокусе ввода                                       |

В некоторых случаях кнопка управления может быть использована для открытия выпадающего меню; такую кнопку называют **кнопкой меню.** Хотя это достаточно специфическое использование кнопок, не предусмотренное системой, вы можете реализовать такой элемент интерфейса, используя стандартные компоненты.

Кнопка меню выглядит как стандартная кнопка управления, за исключением того, что ее метка содержит треугольную стрелку, подобную используемым в каскадных меню.

Кнопка меню поддерживает тот же тип взаимодействия, что и выпадающее меню: меню отображается при нажатии кнопки; выбор пункта меню осуществляется посредством перемещения указателя по панели меню. Подобно любому другому меню, чтобы проследить перемещение указателя, в данном случае также используется подсветка пунктов меню.

Щелчок ЛКМ за пределами меню или повторное нажатие кнопки приводит к закрытию панели меню.

### ПЕРЕКЛЮЧАТЕЛИ

Переключатели, иногда называемы т*акже радиокнопками* предоставляют пользователю возможность выбрать единственный вариант из предлагаемого множества взаимоисключающих альтернатив. Другими словами, в любой группе переключателей может быть установлен (выбран) только один. Поэтому если окно содержит переключатели, относящиеся к разным объектам или к различным свойствам одного объекта, они обязательно должны быть явным образом разделены на соответствующие группы.

Переключатели изображаются в виде небольших кружков, если кнопка выбрана, в середине кружка появляется точка (маркер). Не рекомендуется использовать переключатели для запуска команд (т.е. в качестве кнопок управления). Единственным исключением является случай, когда двойной щелчок ЛКМ на переключателе используется как средство быстрого выбора значения некоторой величины и выполнения встроенной команды окна, которая является основным (или единственно возможным) действием пользователя для данного окна.

Как правило, переключатели используются для выбора одного из возможных значений некоторого свойства объекта. При этом желательно ограничить число различных вариантов (обычно используют не более семи), но вместе с тем их должно быть **не менее двух.** Если необходимо предложить пользователю большее количество вариантов, используйте другие элементы управления, например меню.

Каждый переключатель снабжается текстовой меткой. Если же для пояснения назначения кнопок в группе более удобны графические символы, лучше использовать кнопки управления. Стандартные переключатели позволяют создавать метки, состоящие из нескольких строк. В таких случаях целесообразно использовать верхнее выравнивание (если ситуация не требует какой-либо другой ориентации текста).

Как и для кнопок управления, для выбора переключателя используется щелчок ЛКМ — или в кружке, или на метке кнопки. Фокус ввода перемещается на метку кнопки, если указатель находится над ней или над кружком, когда пользователь нажимает кнопку мыши. Если пользователь перемещает указатель за пределы переключателя, не отпуская кнопку мыши, он возвращается в исходное состояние. Выбор не будет зафиксирован до тех пор, пока пользователь не отпустит кнопку мыши (при этом указатель должен находится над переключателем). Повторный щелчок ЛКМ на том же переключателе не изменяет его состояние; пользователю нужно явно выбрать альтернативный вариант в группе, чтобы изменить или восстановить прежний выбор.

Для работы с переключателями с помощью клавиатуры могут быть определены соответствующие клавиши доступа. Выбор переключателя в группе может также выполняться клавишей *\<Таb\>* и клавишами перемещения курсора.

### ФЛАЖКИ

Подобно переключателям, флажок может находиться в одном из двух состояний: "включено" или "выключено"; применительно к флажкам эти состояния обычно именуются "флажок установлен" или "флажок снят". Основное отличие флажков от переключателей заключается в том, что они используются для отображения независимых вариантов выбора. Другими словами, пользователь может одновременно выбрать (установить) несколько флажков, входящих в одну группу.

Флажок изображается в виде небольшого квадратного окошечка с сопутствующей меткой. Когда флажок установлен, в окошечке появляется маркер.

Стандартный флажок имеет текстовую метку. Если же для пояснения предназначения флажка требуется графический символ, следует использовать вместо флажка кнопку управления. При выборе текста для метки пользуйтесь все тем же золотым правилом: чем короче и содержательнее надпись, тем лучше; если текст не удалось уместить в одну строку, используйте верхнее выравнивание строк (если по контексту не требуется какой-то другой вариант).

В некоторых случаях флажок может использоваться для управления другими элементами интерфейса. В частности, от состояния флажка может зависеть доступность элементов более низкого уровня иерархии

Если список установок содержит большое число пунктов, или если их количество изменяется, вместо флажков удобнее использовать список множественного выбора.

Когда пользователь щелкает ЛКМ в окошечке флажка или на его метке, состояние флажка переключается на противоположное. При нажатии кнопки мыши фокус ввода переходит на флажок. Как и при работе с другими элементами управления, если пользователь, удерживая кнопку мыши, перемещает указатель за пределы флажка, элемент возвращается в исходное состояние. Состояние флажка не изменится, пока кнопка мыши не будет отпущена. Для изменения состояния указатель должен находиться в этот момент над флажком или его меткой.

Чтобы предоставить пользователю клавиатурный интерфейс для управления флажками, определите для каждой из них клавишу доступа. Кроме того, для навигации между кнопками могут поддерживаться клавиша *\<Таb\>* и клавиши управления курсором. Если фокус ввода находится на одном из флажков, отображаемых на диалоговой панели, то для его перемещения между флажками может использоваться клавиша *\<Spacebar\>.*

В некоторых случаях оказывается весьма полезным использование дополнительного, третьего состояния флажка, которое мы в дальнейшем будем называть **промежуточным.**

Примером такой ситуации, в которой целесообразно использовать промежуточное состояние флажка, может служить работа с фрагментом текста, содержащего несколько различных типов шрифта. Если для установки каждого типа шрифта используется отдельная кнопка-флажок, то при выборе «разнородного» фрагмента текста все они должны быть установлены в промежуточное состояние. Если в такой ситуации пользователь выберет (установит) один из флажков, то для всего фрагмента текста будет применен тип шрифта, соответствующий данному флажку. Повторный выбор флажка приводит к изменению его состояния на противоположное (флажок будет снят). Если же флажок будет выбран в третий раз, то он вновь вернется в исходное (промежуточное) состояние; то же самое произойдет и с редактируемым фрагментом текста.

## **СПИСКИ**

Список предоставляет пользователю удобное средство управления выбором требуемых объектов или их свойств. Элементы списков могут быть представлены как в текстовой, так и в графической форме. Любой список как элемент интерфейса должен обеспечивать не только визуальное отображение сделанного пользователем выбора, но и поддержку связанных с выбранными пунктами (или пунктом) действий.

Использование списка является наиболее целесообразным в тех случаях, когда число возможных вариантов выбора велико, либо когда их перечень может изменяться. Если какой-либо элемент списка не может быть выбран в данной ситуации, следует удалить его из списка. Например, если определенный размер не доступен для установленного шрифта, не отображайте этот размер в списке.

Порядок расположения элементов в списке определяется, как правило, его содержанием, и должен облегчать просмотр списка пользователем. Например, если список содержит имена, то их целесообразно расположить по алфавиту; список дат лучше составить в хронологическом порядке.

Стандартный список не снабжается текстовой меткой. Тем не менее, вы можете создать для списка метку в виде статической текстовой области, которая будет использоваться в качестве ссылки для клавиатурного доступа к списку.

Если в текущей ситуации список недоступен, отобразите на экране его метку в соответствующем виде.

Ширина поля списка должна быть достаточной, чтобы разместить в списке название пункта средней длины. Если заранее невозможно подобрать таковую, используйте один из следующих подходов:

• сделайте поле списка достаточно широким, чтобы разместить в нем наиболее «длинный» элемент;

• используйте эллипсис (...) в середине или в конце длинных названий, чтобы сократить их, сохранив при этом те символы, по которым их следует различать. Например, при указании маршрутов доступа наиболее важными являются обычно начало и конец маршрута, поэтому промежуточные каталоги могут быть заменены эллипсисом: *\\0бразец \\... \\Пример;*

• включите в панель списка горизонтальную полосу прокрутки; правда, этот вариант имеет некоторые ограничения по использованию, поскольку наличие полосы прокрутки приводит к сокращению объема данных, которые пользователь может просмотреть одновременно.

Если количество пунктов в списке превышает видимую область, то в поле списка включается вертикальная полоса прокрутки. При этом должны соблюдаться те же правила использования полосы прокрутки, которые были рассмотрены ранее.

Для выбора и прокрутки списка могут быть также использованы клавиши управления курсором. Кроме того, для списка обеспечивается поддержка клавиатурного выбора с помощью текстовых клавиш. Когда пользователь нажимает текстовую клавишу, в списке производится выбор соответствующего пункта, при этом список перемещается таким образом, чтобы выбор был виден пользователю. Последующие нажатия текстовых клавиш обеспечивают продолжение процесса сопоставления слова, набираемого на клавиатуре, с названиями пунктов списка. При этом каждое последующее нажатие клавиши должно быть выполнено в пределах установленной системной задержки. Если задержка истекает, сопоставление возобновляется с первого символа.

Включая список в состав окна приложения, продумайте возможность использования при работе со списком команд редактирования *(Вырезать, Копировать, Вставить)* и операций прямого манипулирования. Если список содержит пиктограммы или величины, которые пользователь может переместить или скопировать в другие позиции окна (например, в другой список), доступность таких операций может существенно ускорить его работу. Для текущего (просматриваемого) списка эти операции поддерживаются автоматически; тем не менее, система обеспечивает возможность реализации указанных операции и для других (не активных) списков.

-   **ТЕКСТОВАЯ ОБЛАСТЬ**

Как правило, окна содержат различные элементы интерфейса, которые обеспечивают отображение, ввод и редактирование текстовых величин. Некоторые из них представляют собой комбинацию области текстового ввода с элементами управления других типов.

В текстовой области не используются текстовые метки в качестве элементов управления. Тем не менее, вы можете дополнить ее статическим текстом, поясняющим назначение текстовой области и обеспечивающим индикацию ситуации, когда область недоступна. Если статический текст состоит из нескольких слов, при его написании целесообразно использовать рассмотренные ранее правила использования заглавных букв. Статический текст может также быть использован для определения клавиши доступа к текстовой области. При этом необходимо помнить, что при нажатии клавиши доступа фокус ввода должен устанавливаться на текстовую область, с которой метка связана, а не на сам статический текст. Вы можете также обеспечить клавиатурную навигацию в текстовой области, используя клавишу *\<Таb\>* и клавиши перемещения курсора.

В тех случаях, когда текстовая область используется для ввода ограниченного множества возможных значений (например, только чисел из заданного диапазона), следует тут же подтверждать правильность ввода или, наоборот, игнорировать неподходящие символы (возможно, выдавая пользователю соответствующее сообщение).

### ТЕКСТОВЫЕ ПОЛЯ

Текстовое поле **(TextBox),** иногда называемое также **полем редактирования** или **полем ввода** *—* это прямоугольная область, в которой пользователь может вводить или редактировать текст. Она может содержать одну или несколько строк. Как правило, граница текстового поля обозначается явным образом, хотя на самом деле это необходимо только в тех случаях, когда текстовое поле расположено на панели инструментов или во вторичном окне.

Для стандартного текстового поля поддерживаются такие операции редактирования, как вставка и удаление символов, а также выделение фрагмента текста. Хотя индивидуальный шрифт для текстового поля обычно не поддерживается, при необходимости такая настройка может быть реализована.

В некоторых случаях текстовое поле может использоваться для вывода на экран текста, который не подлежит редактированию и предназначен только для чтения. Если такое ограничение устанавливается для стандартного текстового поля, система автоматически изменяет цвет его фона, чтобы указать пользователю на данную особенность.

Для текстового поля поддерживается стандартная техника навигации и непрерывного выбора. Если текстовое поле содержит только одну строку, то для него отображается только горизонтальная полоса прокрутки; если же оно содержит более одной строки, то поле снабжается как горизонтальной, так и вертикальной полосами прокрутки.

Вы можете произвольным образом ограничить множество символов, разрешенных для ввода в данное текстовое поле. Кроме того, вы можете реализовать *авто выход,* установив фиксированную длину вводимых строк; это означает, что при вводе последнего символа в текстовое поле фокус ввода автоматически переходит на другой элемент управления. Например, вы можете определить шести символьный авто выход, чтобы облегчить ввод почтового индекса, или три текстовых поля с двухсимвольным авто выходом каждое, предназначенные для ввода даты (число, месяц, год). Хотя авто-выход обладает очевидными достоинствами, не рекомендуется злоупотреблять им, поскольку автоматический перенос фокуса ввода может вызвать замешательство у начинающего пользователя. Ограничьте применение авто выхода ситуациями, связанными с вводом большого объема данных (например, при заполнении экранных форм).

-   **ПАНЕЛЬ ИНСТРУМЕНТОВ И СТРОКА СОСТОЯНИЯ**

Панель инструментов (**Toolbar)** и строка состояния **(Status Bar)** *—* это специальные компоненты пользовательского интерфейса, предназначенные для создания функционально-ориентированных наборов элементов управления. Панель инструментов содержит, как правило, элементы управления, обеспечивающие быстрый доступ к наиболее часто используемым командам или свойствам объектов. Различают несколько типов панелей инструментов, ориентированных на применение в специфических приложениях. Такие специализированные панели иногда имеют собственные названия.

Строка состояния — это специальная область внутри первичного окна (обычно в нижней его части), предназначенная для вывода информации о текущем состоянии объектов или процессов, представленных в окне, а также любой другой контекстной информации, например, о состоянии клавиатуры. Вы можете также использовать строку состояния, чтобы обеспечить вывод справочных сообщений о выбранном пункте меню или кнопке панели инструментов. Подобно панели инструментов, строка состояния может содержать элементы управления; тем не менее, рекомендуется включать в нее информацию «только для чтения» или не интерактивные элементы.

Доступ к элементам управления, включенным в панель инструментов или строку состояния, реализуется либо с помощью мыши, либо через другие стандартные средства взаимодействия с этими элементами. Может быть также реализовано клавиатурное взаимодействие, основанное на использовании горячих клавиш или клавиш доступа. Если элемент панели инструментов или строки состояния не имеет текстовой метки, средства клавиатурного доступа для него оказываются неэффективными. Кроме того, если какая-либо клавиша доступа уже используется в первичном окне, она не может применяться для работы с панелью инструментов. Например, если полоса меню первичного окна уже использует некоторую клавишу доступа, то все события, связанные с этой клавишей, будут обрабатываться применительно к полосе меню.

Когда пользователь взаимодействует с элементом управления, расположенном на панели инструментов или в строке состояния, любое изменение непосредственно относится к текущему выбору (например, если кнопка панели инструментов предназначена для изменения начертания шрифта в тексте, то при нажатии этой кнопки текст немедленно изменяется); никакое дополнительное подтверждение не требуется. Единственное исключение составляет случай, когда использование элемента управления (например, кнопки), требует от пользователя ввода дополнительной информации; соответствующая операция не может быть реализована, пока пользователь не введет требуемую информацию. Примером такого исключения является выбор объекта или установка значения параметра с помощью диалоговой панели.

Для тех элементов панели инструментов или строки состояния, которые не имеют текстовой метки, обязательно должна использоваться всплывающая подсказка. Система поддерживает создание всплывающей подсказки для элементов стандартной панели инструментов.

С целью обеспечения максимальной гибкости в работе пользователей панели инструментов и строки состояния должны допускать индивидуальную настройку. Простейший вариант такой настройки — возможность скрыть (не отображать) эти элементы интерфейса. В более сложных приложениях пользователю предоставляется право изменять или перестраивать элементы, включенные в панели инструментов или строки состояния.

Рекомендуется также обеспечивать возможность отображения каждой кнопки на панели инструментов по крайней мере двух размеров: 24 на 22 и 32 на 30 пикселов. Если для обозначения кнопок используются графические метки, они должны иметь размеры не более чем 16 на 16 и 24 на 24 пикселов соответственно.

Продумайте также возможность создания перемещаемой пользователем панели инструментов. Хотя панель инструментов по умолчанию отображается как **пристыкованная** к определенному краю окна или панели, в которых она используется, разрешите пользователю перемещать ее к другому краю или отображать в виде окна палитры.

-   **СТАНДАРНЫЕ КНОПКИ ПАНЕЛИ ИНСТРУМЕНТОВ**

Табл. 10. иллюстрирует стандартные форматы кнопок «общего назначения» которые могут быть использованы в любом приложении.

Таблица 10.

**Форматы стандартных кнопок панели инструментов**

| **Формат 16х16**                                 | **Формат 24х24**                                 | **Функция**                                                    |
|--------------------------------------------------|--------------------------------------------------|----------------------------------------------------------------|
| ![](/static/lection-images/959c741938eb46c3d1be5139e9059701.jpeg) | ![](/static/lection-images/959c741938eb46c3d1be5139e9059701.jpeg) |  Создать (New)                                                 |
| ![](/static/lection-images/5895ec19edfaa4f41b85bf0840699300.jpeg) | ![](/static/lection-images/5895ec19edfaa4f41b85bf0840699300.jpeg) |  Открыть (Open)                                                |
| ![](/static/lection-images/a92fd410b9a6ffacab1fede4b338874c.jpeg) | ![](/static/lection-images/a92fd410b9a6ffacab1fede4b338874c.jpeg) |  Сохранить (Save)                                              |
| ![](/static/lection-images/08d323e7b5a0f0812ddf37f063e17951.jpeg) | ![](/static/lection-images/08d323e7b5a0f0812ddf37f063e17951.jpeg) |  Печать (Print)                                                |
| ![](/static/lection-images/154db33438671fa6dc087bac3e20f5b6.jpeg) | ![](/static/lection-images/154db33438671fa6dc087bac3e20f5b6.jpeg) |  Предварительный просмотр (Print Preview)                      |
| ![](/static/lection-images/d0e4a000af07eece5b3aa2fd8ec7ee99.jpeg) | ![](/static/lection-images/d0e4a000af07eece5b3aa2fd8ec7ee99.jpeg) |  Отменить (Undo)                                               |
| ![](/static/lection-images/3a4d28e3c462bc5dee7fc24c88b421ea.jpeg) | ![](/static/lection-images/3a4d28e3c462bc5dee7fc24c88b421ea.jpeg) |  Повторить (Redo)                                              |
| ![](/static/lection-images/2b92019e8a32e58cab30242bf73598ed.jpeg) | ![](/static/lection-images/2b92019e8a32e58cab30242bf73598ed.jpeg) |  Вырезать (Cut)                                                |
| ![](/static/lection-images/36ac5e874ef47c8f79cbd6e1cfa6b353.jpeg) | ![](/static/lection-images/36ac5e874ef47c8f79cbd6e1cfa6b353.jpeg) |  Вставить (Paste)                                              |
| ![](/static/lection-images/44a91c0b5564d4ee4da15d6f28f8ed71.jpeg) | ![](/static/lection-images/44a91c0b5564d4ee4da15d6f28f8ed71.jpeg) |  Копировать (Copy)                                             |
| ![](/static/lection-images/75af69804688bc95d13ef471d5488d01.jpeg) | ![](/static/lection-images/75af69804688bc95d13ef471d5488d01.jpeg) |  Удалить (Delete)                                              |
| ![](/static/lection-images/49348d0be326b305ca52d49b960d1d95.jpeg) | ![](/static/lection-images/49348d0be326b305ca52d49b960d1d95.jpeg) |  Найти (Find)                                                  |
| ![](/static/lection-images/e3d4e979d0d416c2e8c7e879771e7c6e.jpeg) | ![](/static/lection-images/e3d4e979d0d416c2e8c7e879771e7c6e.jpeg) |  Заменить (Replace)                                            |
| ![](/static/lection-images/8751d7b0bd3fa43959223dd0770d424f.jpeg) | ![](/static/lection-images/8751d7b0bd3fa43959223dd0770d424f.jpeg) |  Полужирный [курсив] (Bold)                                    |
| ![](/static/lection-images/17c0c22dd0cdd6651a1e97733e3fe244.jpeg) | ![](/static/lection-images/17c0c22dd0cdd6651a1e97733e3fe244.jpeg) |  Курсив(Italic)                                                |
| ![](/static/lection-images/3a6695eb34d0c718f14d315e5d20a39b.jpeg) | ![](/static/lection-images/3a6695eb34d0c718f14d315e5d20a39b.jpeg) |  Подчёркнутый [шрифт] (Underline)                              |
| ![](/static/lection-images/e82a1d43b188ebb390c431ed6d1ca059.jpeg) | ![](/static/lection-images/e82a1d43b188ebb390c431ed6d1ca059.jpeg) |  Свойства (Properties)                                         |
| ![](/static/lection-images/b0b1dde0aa865a369696867054c641a9.jpeg) | ![](/static/lection-images/b0b1dde0aa865a369696867054c641a9.jpeg) |  Что Это? [режим контекстно-зависимой подсказки] (What’s This) |
| ![](/static/lection-images/c1c7619d6af276b4196b3f115c9fa37c.jpeg) | ![](/static/lection-images/c1c7619d6af276b4196b3f115c9fa37c.jpeg) |  Открыть родительскую папку (Open parent folder)               |
| ![](/static/lection-images/df501636b59a26b1b6fae4c393fb8964.jpeg) | ![](/static/lection-images/df501636b59a26b1b6fae4c393fb8964.jpeg) |  Отобразить как крупные пиктограммы (View as large icons)      |
| ![](/static/lection-images/2c63c1a440ce8c72c90e74aa8bc689d8.jpeg) | ![](/static/lection-images/2c63c1a440ce8c72c90e74aa8bc689d8.jpeg) |  Отобразить как мелкие пиктограммы (View as small icons)       |
| ![](/static/lection-images/c0610a0116f875c0d6b9b92b55d0f4ff.jpeg) | ![](/static/lection-images/c0610a0116f875c0d6b9b92b55d0f4ff.jpeg) |  Отобразить в виде списка (View as list)                       |
| ![](/static/lection-images/0fb55c9bbb6e8bb214366bdf4fa63ff5.jpeg) | ![](/static/lection-images/0fb55c9bbb6e8bb214366bdf4fa63ff5.jpeg) |  Отобразить в виде таблицы (View as details)                   |
| ![](/static/lection-images/87fe8588f6e10d73269874a6831358fd.jpeg) | ![](/static/lection-images/87fe8588f6e10d73269874a6831358fd.jpeg) |  Выделить (выбрать) область (Region selection tool)            |

1.  **Проектирование средств поддержки пользователя**

Средства оперативной поддержки пользователя являются важной частью приложения и могут быть реализованы различными способами, от использования команд явного вызова помощи до автоматического отображения справочной информации, соответствующей текущей ситуации. Содержание выводимых сообщений также может носить разнообразный характер и представлять собой либо краткое пояснение, либо ссылку на другой источник информации, либо своеобразный электронный учебник. Но помощь пользователю должна быть всегда простой, эффективной и своевременной, чтобы пользователь мог получить ее до того, как будет вынужден прекратить работу.

**ОКНО СООБЩЕНИЕ**

Окно *СООБЩЕНИЕ (Message Box) —* это вторичное окно, используемое для вывода на экран сообщений пользователю; как правило, сообщения содержат информация о конкретной ситуации или условиях выполнения операций. Сообщения являются важной частью пользовательского интерфейса любого программного продукта. В связи с этим разработке сообщений должно быть уделено самое пристальное внимание. Вообще же лучше избегать ситуаций, которые требуют вывода сообщений. Например, если может возникнуть ситуация, связанная с нехваткой свободного дискового пространства для продолжения работы, следует ее предотвратить вместо того, чтобы потом сообщать о ней пользователю.

**Форматы окна СООБЩЕНИЕ**

Как правило, окно *СООБЩЕНИЕ* содержит графический символ, который указывает на тип выводимого сообщения. Большинство используемых на практике сообщений могут быть отнесены к одной из следующих категорий (табл. 11).

Таблица 11.

Графические обозначения типов сообщений

| **Символ**                                         | Тип сообщения        | **Описание**                                                                                                                                                                                                                                                                                                                                                            |
|----------------------------------------------------|----------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  ![](/static/lection-images/45db07adbbf3d589f749edfb4586e07d.jpeg)  | Информация           | Предоставляет пользователю информацию о результатах выполнения команды. Пользователю не предлагается возможность выбора; считается, что он принял сообщение к сведению, если нажал кнопку ОК                                                                                                                                                                            |
|   ![](/static/lection-images/0a0e768553c177d4f35a1daadc448f75.jpeg) | Предупреждение       | Предупреждает пользователя о возникновении ситуации, которая требует от него выбора одного из возможных вариантов последующих действий приложения или системы; используется в тех случаях, когда предстоящая операция является потенциально опасной или имеет необратимые последствия. Сообщение может быть в форме вопроса, например, "Сохранить внесенные изменения?" |
|  ![](/static/lection-images/de3d036520ba76312349284514235db7.jpeg)  | Критическая ситуация | Информирует пользователя о серьезной проблеме, которая требует его вмешательства или внесения каких-либо изменений прежде, чем работа могла бы продолжиться                                                                                                                                                                                                             |

**Примеры использования различных типов сообщений**

Не рекомендуется снабжать окно сообщения символом в виде знака вопроса, использовавшимся в ранних версиях ОС Windows, поскольку предполагается, что пользователи могут воспринять такое сообщение как справочную информацию, выдаваемую при запросе помощи. Тем не менее, практика показывает, что такая ассоциация встречается все реже и реже, и во многих приложениях используются окна сообщений, содержащие знак вопроса; как правило, такие сообщения применяются в тех случаях, когда пользователь должен уточнить тот или иной момент, влияющий на дальнейшее выполнение задания.

**Выбор текста сообщений**

Текст сообщения должен быть ясным, кратким, и использовать терминологию, понятную пользователю. Не рекомендуется применять в сообщениях технический жаргон или системную информацию (особенно в приложениях, ориентированных на непрограммирующих пользователей).

Рекомендации по составлению сообщений можно сформулировать в виде следующих руководящих принципов:

• В тексте сообщения должны содержаться: краткая формулировка проблемной си- , туации, ее вероятная причина (если она известна), и рекомендации относительно возможных действий пользователя (даже если решение представляется разработчику очевидным). Например, вместо сообщения «Недостаточно места на диске» следует использовать, например, такое: «Невозможно сохранить файл, поскольку диск заполнен. Попробуйте сохранить его на другом диске или освободите место на этом же диске».

• Если у пользователя имеется несколько вариантов решения проблемы, изложите сообщение так, чтобы максимально облегчить пользователю выбор. Например, вместо сообщения «Одна или более строк превышают допустимую длину (60 символов)» лучше использовать такое: «Одна или более строк превышают допустимую длину. Строка может содержать максимум 60 символов при вертикальной ориентации бумаги или 90 символов при горизонтальной. Вы хотите переключиться на горизонтальную ориентацию сейчас?» В качестве вариантов ответа предложите пользователю «Да» и «Нет».

• Избегайте использования необязательных технических терминов и чрезмерно сложных предложений. В первую очередь это относится к использованию в сообщениях англоязычных терминов в русской транскрипции, таких как «спиннер», «баннер» и т.д.

• Текст сообщения не должен содержать обвинений в адрес пользователя или носить нравоучительный характер. Например, вместо «Ошибка при вводе имени

файла» лучше написать «Не могу найти файл с таким именем, проверьте правильность ввода». Вообще крайне нежелательно появление в сообщении слова «ошибка»

• Сообщение должно быть как можно более конкретным. Не используйте одно и то же окно сообщения для описания нескольких проблемных ситуаций одновременно. Например, если существуют различные причины, по которым файл не может быть открыт, сформируйте отдельное сообщение для каждого случая.

• Старайтесь избегать использования стандартных системных сообщений типа «Ошибка ядра ОС INT 244», заменяя их по возможности собственными сообщениями, ориентированными на пользователя.

• Текст сообщения должен быть хотя и достаточно полным, но в то же время лаконичным. Практика показывает, что хорошо продуманное сообщение умещается в двух — трех строках. Если необходимо более подробное пояснение, включите в окно сообщения кнопку *Справка.*

При необходимости каждое сообщение может быть снабжено идентификационным номером, однако, чтобы он не мешал пользователям воспринимать текст сообщения, помещайте его в конце текста сообщения; не рекомендуется также включать номер сообщения в заголовок окна.

**КОНТЕКСТНАЯ ПОМОЩЬ**

Контекстная помощь обеспечивает предоставление пользователю информации о конкретном объекте или ситуации. Она реализуется в виде ответов на вопросы типа «Что это?» и «Как я должен использовать это?» В данном разделе представлены некоторые основные способы использования контекстной помощи пользователю в создаваемом приложении.

### КОМАНДА *ЧТО ЭТО?*

**Команда Что** *это? (What's This?)* обеспечивает пользователя контекстной информацией относительно любого объекта, представленного на экране, включая элементы управления на панелях свойств и других диалоговых панелях. Эта форма контекстной помощи пользователю называется **контекстно-зависимой подсказкой.** Как показано на рис. 6.6, доступ пользователя к этой команде может быть реализован одним из следующих способов:

• Через выпадающее меню *Справка* первичного окна.

• С помощью кнопки на панели инструментов.

• С помощью кнопки, расположенной в полосе заголовка вторичного окна.

• Через всплывающее меню конкретного объекта.

**Различные методы доступа к команде Что это?**

Когда пользователь выбирает команду *Что это?* из меню *Справка* или нажимает соответствующую кнопку на панели инструментов, система переходит во временный режим **(режим подсказки).** Визуальным признаком этого режима служит изменение формы указателя. Альтернативным средством перехода в режим подсказки является комбинация клавиш *\<Shift\>+Fl.*

**Правила создания контекстно-зависимой подсказки**

Контекстно-зависимая подсказка может быть сформулирована в виде ответа на вопросы «Что это?», «Почему?» или «Каким образом?», но, если процедура требует выполнения нескольких шагов, продумайте возможность предоставления пользователю соответствующей информации в форме помощи, **ориентированной на задание** (подробнее этот подход будет рассмотрен ниже). Содержание подсказки должно быть кратким и вместе с тем достаточно полным, чтобы пользователь мог быстро прочитать ее и уяснить смысл.

Как один из допустимых вариантов, может быть реализована контекстно-зависимая справка для типов файлов, поддерживаемых вашим приложением. Это позволит пользователю, выбрав команду *Что это?* из всплывающего меню пиктограммы файла, получить о нем необходимую информацию (рис. 3).

![](/static/lection-images/8e8637c0a6f00b46095eab11654177be.jpeg)

Рис. 3., Контекстно-зависимая справка для пиктограммы файла

### 

### ВСПЛЫВАЮЩАЯ ПОДСКАЗКА

Другой формой контекстной помощи пользователю является всплывающая подсказка *(tooltips).* **Всплывающая подсказка** *—* это небольшое всплывающее окно, которое содержит название элемента управления, не имеющего текстовой метки. Наиболее распространенный вариант использования такой подсказки — пояснения для кнопок панели инструментов, которые имеют только графическое обозначение.

Всплывающая подсказка появляется возле указателя, если он находится над кнопкой в течение некоторого (достаточно короткого) интервала времени и остается на экране, пока пользователь не нажмет кнопку мыши или не переместит указатель, либо в течение установленного периода времени. Если пользователь перемещает указатель на другой элемент управления, поддерживающий всплывающую подсказку, задержка игнорируется, и новая подсказка отображается немедленно, заменяя предыдущую.

Для стандартных элементов управления система автоматически обеспечивает всплывающую подсказку. Если вы создаете собственные окна всплывающей подсказки обеспечьте их согласованность с существующими системными окнами подсказки.

### ВЫВОД СООБЩЕНИЙ В СТРОКЕ СОСТОЯНИЯ

Контекстная помощь пользователю может также быть реализована на основе строки состояния. Однако, если пользователю предоставлено право выбора, отображать или нет строку состояния, то лучше ее не использовать в этих целях (если альтернативные средства доступа к выводимой в ней информации отсутствуют). Кроме того, поскольку строка состояния не всегда находится в центре внимания пользователя, то он может не обратить внимание на появившееся там сообщение. Поэтому следует рассматривать вывод сообщений в строке состояния лишь как дополнительную форму помощи пользователю.

Как уже было сказано, в строке состояния наряду с информацией о текущей ситуации могут отображаться краткие сведения о выбираемых пунктах меню и кнопках панели инструментов. Как и при использовании всплывающей подсказки, соответствующее окно должно быть активным. Описание интересующего элемента отображается в строке состояния, когда пользователь перемещает курсор на кнопку панели инструментов или на один из пунктов меню.

### КНОПКА *СПРАВКА*

Выдача контекстной справочной информации можете также быть реализована для таких элементов интерфейса, как панель свойств, диалоговая панель или окно сообщения. С этой целью в них должна быть включена кнопка *Справка.* При «нажатии» пользователем этой кнопки должно открываться не всплывающее окно контекстно-зависимой подсказки, а вторичное окно, содержащее соответствующую справочную информацию.

Помощь, предоставляемая пользователю по этой команде, отличается по форме от подсказки, выводимой по команде *Что это?* Она должна обеспечить пользователя более полной, развернутой пояснительной информацией по данному окну. Например, для окна Сообщение это может быть более подробная информации о причинах и способах устранения возникшей ситуации.

С развитием средств оперативной помощи пользователям через Интернет многие приложения обеспечивают доступ к ним также посредством кнопки *Справка.*

Вместе с тем, следует иметь в виду, что использование команды *Справка* является дополнительной, вспомогательной формой контекстной помощи пользователю, которая не должна подменять контекстно-зависимую подсказку, вызываемую по команде *Что это?* Нельзя также рассчитывать на то, что наличие подробной справочной информации может компенсировать недостатки неудачно спроектированного интерфейса вторичных окон.

## **ПРОБЛЕМНО-ОРИЕНТИРОВАННАЯ ПОМОЩЬ**

Проблемно-ориентированная **помощь (Task-Oriented Help)** представляет собой описание последовательности шагов, необходимых для выполнения некоторого задания пользователя. Для предоставления пользователю проблемно-ориентированной помощи соответствующая справочная информация организуется в виде разделов, каждый из которых описывает отдельный шаг задания. В свою очередь, каждый такой раздел отображается на экране в виде отдельного окна, называемого окном **Раздел задания.**

Окно Раздел задания (*Task Topic Window*) — это первичное окно, для которого поддерживаются в основном те же правила взаимодействия, что и для любого другого первичного окна. В частности, пользователь может изменять размер этого окна, сворачивать его и т.п.

Классификация окна Раздел задания как первичного окна обусловлена спецификой его отображения и использования. Вместе с тем, в некоторых вариантах технической документации окно этого типа названо **вторичным окном помощи.**

Первоначальный доступ к любому из окон разделов задания пользователь получает через *броузер разделов,* описанный ниже в этой главе. Вместе с тем, доступ к некоторым разделам может быть реализован посредством *навигационных ссылок,* установленных в других окнах разделов задания.

Окно Раздел задания содержит в верхней части набор кнопок, которые обеспечивают пользователю доступ к броузеру разделов, к предыдущей выбранной теме, а также к другим командам (например, копирования и вывода на печать содержимого окна). Разработчик приложения может сам определить, какие кнопки используются в окне Раздел задания.

## **СПРАВОЧНИК**

Справочник *{Reference Help)* обеспечивает предоставление пользователю справочной информации в форме интерактивной документации. Использование Справочника помогает пользователю уяснить общие основные характеристики программного продукта.

В качестве основы для создания Справочника используется первичное окно, отличающееся по структуре от рассмотренного выше окна Раздел задания.

Доступ к Справочнику может быть реализован несколькими способами. Наиболее распространенный из них — явный вызов посредством соответствующей команды из выпадающего меню *Справка (Help),* но возможны также использование специальной кнопки на панели инструментов или вызов через пиктограмму конкретного объекта.

Окно Справочника содержит полосу меню с разделами *Файл (File), Правка (Edit), Закладка (Bookmark), Параметры (Options)* и *Помощь (Help),* а также панель инструментов с кнопками *Содержание (Contens), Указатель (Index), Назад (Back)* и *Печать (Print).* Для окна справочника система поддерживает перечисленные элементы по умолчанию. Они обеспечивают выполнение пользователем таких операций, как открытие конкретного Help-файла (используя броузер разделов), копирование и печать содержимого страницы Справочника, создание комментария и закладки для данной страницы, а также настройку параметров окна. Разработчик может добавить и другие кнопки, отвечающие конкретному варианту реализации Справочника.

Хотя Справочник может содержать информацию подобную той, которая выводится в окнах контекстной подсказки и проблемно-ориентированной помощи, эти формы помощи не исключают друг друга. Зачастую именно разумное сочетание всех этих средств оказывается наиболее эффективным с точки зрения помощи пользователю.

Каждое окно (страница) Справочника может включать текст, графику, элементы анимации, видеоклипы и даже звуковое сопровождение. Кроме того, система поддерживает некоторые специальные средства, которые рассматриваются ниже.

**Использование ссылок**

Ссылка — это кнопка или интерактивная область, щелчок на которой активизирует некоторое событие. С помощью ссылок может быть реализована однонаправленная связь между страницами Справочника, а также переходы в пределах одного окна либо к другому Help-файлу.

Ссылка может также использоваться для вызова всплывающего окна, содержащего пояснительную информацию о каком-либо понятии или объекте, подобно всплывающему окну контекстно-зависимой подсказки.

Кроме того, ссылка может служить средством запуска некоторых команд, аналогично тому, как кнопки-акселераторы используются в окне Раздела задания.

Ссылка должна визуально отличаться от других, не интерактивных областей окна. Например, она может быть реализована в виде кнопки, либо может изменяться форма указателя, когда пользователь перемещает его на ссылку, либо для нее могут применяться специальные цвет или шрифт (или комбинация этих средств). По умолчанию для обозначения текстовых ссылок используется подчеркнутый шрифт зеленого цвета.

**Броузер разделов**

Броузер разделов представляет собой диалоговую панель, которая обеспечивает пользователю доступ к перечню разделов справочной информации. Для вызова этой диалоговой панели раздел меню *Справка* должен содержать соответствующий пункт (например, *Разделы справочника),* либо команды, позволяющие открывать конкретную вкладку панели *(Содержание, Предметный указатель* или *Поиск).* Кроме того, соответствующая кнопка вызова должна присутствовать на панели инструментов окна приложения или окна Справочника.

Когда пользователь вызывает броузер разделов, он должен быть открыт на той вкладке, с которой пользователь работал последний раз.

Как было указано ранее, стандартный броузер разделов содержит три вкладки *(Содержание, Предметный указатель* и *Поиск).* Однако разработчик имеет право создать собственную дополнительную вкладку.

**Вкладка Содержание**

На данной вкладке отображается список тем, упорядоченный по их содержанию. Пиктограмма в виде книги указывает на наличие нескольких связанных тем (разделов), а пиктограмма в виде страницы обозначает одну отдельную тему. Каждый раздел или группа разделов могут входить в раздел более высокого уровня, однако не рекомендуется использовать более трех уровнен вложенности, поскольку это может затруднить пользователю поиск информации.

Кнопки, расположенные в нижней части вкладки, позволяют пользователю открывать или закрывать выбранную тему (группу тем), а также выводить на печать их содержимое. Открыть интересующий раздел пользователь также может с помощью двойного щелчка ЛКМ на его названии или пиктограмме.

Порядок расположения тем в списке и их наименование определяет разработчик приложения, исходя из того, что пользователь должен уяснить взаимосвязь между темами и характер приведенной в них информации.

**Вкладка Предметный указатель**

Список, отображаемый на этой вкладке, упорядочен, по ключевым словам, которые расположены в алфавитном порядке; перечень ключевых слов для каждой темы определяет разработчик.

Для получения справки по интересующему его понятию пользователь может либо ввести ключевое слово в текстовом поле, либо выбрать его из списка. Кнопка *Вывести (Display)* выводит на экран раздел Справочника, содержащий это ключевое слово. Если имеется несколько разделов, в которых используется данное ключевое слово, то открывается дополнительное вторичное окно, которое позволяет пользователю выбрать одну из этих тем. Вы можете также использовать это окно, чтобы отобразить связанные темы, когда пользователь выбирает кнопку *Смотри также (See Also)* в окне Справочника.

При выборе ключевых слов следует руководствоваться следующими основными принципами:

• Используйте одновременно два варианта ключевых слов: для начинающих и подготовленных пользователей.

• Используйте несколько синонимов для обозначения одного понятия.

• Придерживайтесь общепринятой терминологии для данной предметной области.

• Используйте как достаточно общие понятия, относящиеся к данной теме, так и более конкретные.

**Вкладка Найти (Find)**

Вкладка *Найти* обеспечивает поиск любого указанного пользователем слова (или фразы) по всему тексту Help-файла. Эта возможность требует наличия индексного файла, который либо создается разработчиком заранее, при создании Help-файла, либо динамически, когда пользователь выбирает соответствующую команду на вкладке *Найти.*

В связи с усилением ориентации разработчиков программного обеспечения на требования и особенности Интернета пользовательский интерфейс приложений в последнее время претерпевает существенные изменения. Анализу этих тенденций посвящен отдельный раздел книги. Тем не менее, поскольку указанные изменения относятся и к средствам помощи пользователю, здесь уместно привести новый формат Справочника, предложенный фирмой Microsoft, и дать его краткую характеристику.

С точки зрения пользовательского интерфейса новый Справочник представляет собой первичное окно, разделенное на два подокна; одно из них обеспечивает работу с броузером разделов, а второе предназначено для отображения содержимого выбранного раздела.

Новый формат Справочника можно условно назвать «Интернет-ориентированным», поскольку и по внешнему оформлению, и по имеющимся в окне элементам управления он согласован с «Интернет-обозревателем» MS Internet Explorer. В частности, через меню *Параметры* (команда *Параметры Интернета)* можно получить доступ к панели свойств Internet Explorer.

Броузер разделов в новом Справочнике имеет прежнюю структуру; при необходимости его окно можно скрыть, либо воспользовавшись соответствующей командой (или кнопкой на панели инструментов), либо переместив к левой границе окна полосу разделения подокон.

Еще одним важным признаком Интернет-ориентированности нового Справочника является отказ от двойного щелчка ЛКМ как средства ускоренного открытия (в данном случае — раздела Справочника). Теперь выбор раздела происходит при позиционировании на нем указателя мыши (при этом изменяется форма указателя, а для открытия выбранного раздела достаточно однократного щелчка Л КМ.

## **МАСТЕРА**

Мастер (Wizard) представляет собой специальную форму помощи пользователю, которая позволяет автоматизировать выполнение задания посредством ведения диалога с пользователем. Мастера используются в тех случаях, когда выполняемое задание является достаточно сложным и требует значительного опыта в работе с приложением. Вообще же диапазон применения Мастеров весьма широк: с их помощью может быть автоматизировано практически любое задание, включая создание новых объектов (например, построение графика) или форматирование уже существующих (например, таблицы или параграфа). Тем не менее, Мастеров не следует использовать для обучения пользователя: хотя они и помогают пользователю в выполнении задания, Мастера должны разрабатываться таким образом, чтобы скрыть от него многие шаги задания и внешне упростить задание. Аналогично, Мастера не должны использоваться в качестве электронного учебника; Мастер должен оперировать с реальными данными. Для консультации пользователя следует применять либо рассмотренные выше средства помощи (в частности, проблемно-ориентированную помощь), либо специальные средства обучения, о которых будет сказано ниже. Не стоит также рассчитывать на то, что применение Мастеров позволит повысить качество непродуманного или сложного интерфейса приложения.

Более того, Мастеров следует рассматривать лишь как дополнение к основным инструментам приложения, предназначенным для выполнения конкретного задания.

Другими словами, Мастер — это средство помощи пользователям, позволяющее им наиболее эффективным образом выполнить достаточно сложное или редко встречающееся задание. В связи с этим доступ к Мастерам не обязательно должен быть реализован так же, как к другим средствам помощи. Для этого может быть использован целый ряд иных способов, например кнопки панели инструментов или специальные пиктограммы, обеспечивающие доступ к так называемым *шаблонам (templates).*

С точки зрения пользовательского интерфейса Мастер — это набор диалоговых панелей, последовательно отображаемых на экране по мере выполнения пользователем очередного шага задания.

Система обеспечивает поддержку создания Мастеров на базе стандартных панелей свойств. Каждая такая панель содержит элементы интерфейса, позволяющие пользователю ввести (или выбрать) данные, необходимые для выполнения очередного шага задания.

При необходимости Мастер может быть реализован и на основе связанных вторичных окон «общего назначения», однако это может привести к неэффективному использованию пространства экрана и затруднит ориентацию пользователя. В связи с этим рекомендуется включать в состав Мастера не более одного вторичного окна.

В общем случае каждое окно Мастера должно содержать следующие кнопки (табл. 12.)

Та6лица 12.

Кнопки, используемые в окнах Мастера

| **Команда**       | **Действие**                                                                                                                                           |
|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------|
| \< Назад (Back)   | Возврат на предшествующую страницу (кнопка недоступна на первой странице)                                                                              |
| Далее \> (Next)   | Переход на следующую страницу в последовательности; выполняется независимо от того, какие параметры установил пользователь на предшествующих страницах |
| Готово (Finish)   | Применяет введенные пользователем или установленные по умолчанию значения параметров со всех страниц и инициирует выполнение задания                   |
| Отменить (Cancel) | Отменяет все установленные пользователем значения параметров, завершает процесс и закрывает окно Мастера                                               |

Перечисленные выше кнопки помещаются в нижней части окна, причем во всех окнах они должны располагаться в одной и той же последовательности.

Мастера целесообразно придерживаться следующих основных правил:

• Количество страниц, требующих отображения дополнительного вторичного окна, должно быть минимальным.

• Избегайте такой организации работы Мастера, при которой пользователь будет вынужден самостоятельно выполнять некоторые шаги задания.

• Графические элементы страниц Мастера должны быть реализованы таким образом, чтобы пользователю было понятно, какие из них носят иллюстративный характер, а какие являются интерактивными элементами интерфейса; как правило, иллюстрации имеют больший размер и более абстрактную форму.

• Избегайте автоматического «пролистывания» страниц Мастера, поскольку пользователь может не успеть прочитать информацию. Кроме того, использование Мастера предполагает возможность управления со стороны пользователя выполняемым заданием.

• При инициализации Мастера его окно должно появляться на экране таким образом, чтобы пользователь однозначно воспринимал его как начальную точку выполнения задания.

• Старайтесь убедить пользователя, что значения параметров, предлагаемые Мастером по умолчанию, обеспечивают достижение положительного результата; в некоторых случаях пользователю может быть предложено несколько различных вариантов с соответствующими пояснениями.

• Следует сделать очевидным для пользователя завершение ввода данных, необходимых для выполнения задания; в частности, на последней странице Мастера может быть помещено соответствующее пояснение.

При составлении текстовых комментариев, помещаемых на страницах Мастера, следует использовать диалоговый, а не «справочный» стиль. Практика показывает, что пользователи (особенно начинающие) лучше реагируют на вопросы типа «Как бы Вы хотели это сделать?», чем на сообщения типа «Сделайте то-то». Например, вопрос «В каком формате Вы хотите получить результат?» предпочтительнее, чем предложение «Выберите формат представления результата».

## **СРЕДСТВА ОБУЧЕНИЯ ПОЛЬЗОВАТЕЛЯ**

Практика показывает, что даже при наличии полной и подробной документации на программный продукт, но выполненной в печатной форме, пользователи предпочитают осваивать его методом «проб и ошибок».

Рассмотренные в предыдущих подразделах средства предназначены для оказания пользователю оперативной помощи, то есть так или иначе эти средства являются контекстно-зависимыми и предоставляют ему «конкретный ответ на конкретный вопрос». Несколько особняком стоит в их ряду Справочник, разделы которого не связаны непосредственно с текущим контекстом выполняемого задания, но и он используется обычно в качестве развернутого «толкового словаря», а не «книги для чтения». Для тех приложений, которые реализуют небольшой перечень функций (причем одним определенным образом), средств оперативной поддержки пользователя вполне достаточно, чтобы помочь ему при возникновении затруднений. Однако для более сложных приложений, которые обычно именуются «интегрированными средами» или «пакетами», требуется создание специальных средств обучения пользователей технологии работы с этими приложениями. Их наличие необходимо и в том случае, если создаваемое приложение предназначено для определенной категории пользователей (либо не знакомых с той предметной областью, к которой относится приложение, либо имеющих недостаточный уровень «компьютерной грамотности»). Номенклатура и способ реализации используемых в приложении средств обучения зависит от целого ряда факторов:

• назначения и уровня сложности приложения,

• характеристик потенциальных пользователей,

• времени, отводимого на изучение приложения.

В рамках одного предложения могут использоваться различные варианты средств обучения, относящиеся как ко всему приложению, так и к отдельным его компонентам (либо предназначенные для различных групп пользователей). При этом пользователю должна быть предоставлена и свобода выбора средств обучения, и возможность отключения любого из них.

С их помощью может обеспечиваться достижение следующих уровней обучения:

1) «стимул-ответ» — вырабатывается точная реакция обучаемого на заданный стимул (например, для вызова всплывающего меню объекта требуется щелкнуть ПКМ на его пиктограмме);

2) обучение цепочкам событий — уяснение требуемой последовательности действий, необходимой для решения определенной задачи (например, для коррекции содержимого файла: открыть – отредактировать - записать);

3) концептуальное обучение — пользователь должен научиться определять общие свойства множества объектов (например, определять перечень разрешенных операций для графических объектов);

4) обучение правилам — предполагает обучение логическому увязыванию между собой концепций (например, пользователь должен уяснить правила применения технологии OLE для объектов различных типов);

5) обучение решению задач — означает формирование навыков в работе с приложением при решении конкретных задач (например, пользователь должен научиться выполнять распределение ресурсов в рамках имеющегося календарного графика).

Практически для всех перечисленных вариантов справедливы следующие общие требования к функционированию средств обучения:

• должны обеспечивать наличие обратной связи (обучаемый должен знать, какой результат дает каждое его действие);

• время реакции системы на действия пользователя должно быть минимальным;

• работа средств обучения в целом должна характеризоваться доброжелательным отношением к обучаемому.

К наиболее распространен иным в настоящее время «встроенным» средствам обучения относятся:

• «Полезные советы» (*Tip of the Day,* в терминологии разработчиков локализованной версии MS Office — Мастер подсказок);

• Подборки примеров, иллюстрирующих результаты применения приложения для решения различных задач;

• Демонстрационные ролики;

• Электронные учебники.

1.  **Средства реализации пользовательского интерфейса**

## **КЛАССИФИКАЦИЯ СРЕДСТВ РАЗРАБОТКИ ПОЛЬЗОВАТЕЛЬСКОГО ИНТЕРФЕЙСА**

Технология построения пользовательского интерфейса и инструментальные средства, используемые для ее реализации, образуют единое целое. Очередной шаг в развитии любой из этих составляющих дает толчок к дальнейшему развитию другой. Материальной же основой существования любого пользовательского интерфейса является перечень устройств ввода/вывода, доступных конечному пользователю. В те далекие времена, когда единственным средством ввода информации в ЭВМ служило устройство чтения с перфокарт, а средством вывода - его брат-близнец для вывода на перфокарты, ни один объектно-ориентированный язык программирования не помог бы представить пользователю результаты иначе, как в виде дырочек на перфокарте. Другими словами, тогда проблемы реализации пользовательского интерфейса для программистов просто не существовало («нет интерфейса - нет проблем»).

С появлением алфавитно-цифровых (символьных) устройств ввода/вывода, таких как алфавитно-цифровые дисплеи (АЦД) и алфавитно-цифровые печатающие устройства (АЦПУ), в языки программирования были включены соответствующие операторы (либо библиотечные функции), предназначенные для реализации взаимодействия пользователя с этими устройствами. На данном этапе технология программирования компонентов, относящихся к пользовательскому интерфейсу, практически не отличалась от программирования остальных функций приложения, да и сами эти компоненты были как бы «размазаны» по всей программе. Впоследствии такая технология получила наименование «внутреннее управление интерфейсом». Опирается она в основном на процедурные языки программирования, как высокого уровня (Фортран, Паскаль, Си), так и машинно-ориентированные (типа ассемблера). Очевидно, что при таком подходе разработка интерфейса как самостоятельной компоненты программной системы практически невозможна. Хотя упомянутые выше процедурно-ориентированные языки не зря называются универсальными и позволяют реализовать любой тип интерфейса (в том числе и GUI), трудозатраты на практическую реализацию такой затеи могут оказаться не по силам подавляющему большинству разработчиков. Кроме того, необходимость «ручного» описания огромного числа атрибутов интерактивных компонентов приложения делает невозможной стандартизацию этих компонентов. В определенной степени упростить решение указанной задачи позволило появление проблемно-ориентированных языков программирования, таких как языки моделирования (*SIMULA, GPSS, SOL*) и языки управления базами данных (*Clipper, dBASE, PAL*). Особую группу процедурных языков образуют так называемые языки диалогового взаимодействия (или командные языки), созданные специально для облегчения работы пользователей в интерактивном режиме. Основу синтаксиса этих языков составляют макрокоманды (или макро-операторы.), реализующие определенную последовательность действий по вводу/ выводу данных. Например, один из языков диалогового взаимодействия - ДИ-ФОЛ - содержит такие операторы:

*DISPLAY -* вывести информацию на экран;

*UPR* - создать незащищенное поле ввода;

*NUM* - создать цифровое поле;

*BRO* — создать неотображаемое поле;

*BR1* — создать поле нормальной яркости;

*BR2* — создать поле, отображаемое с повышенной яркостью.

Более того, в составе СУБД Paradox имеется так называемый генератор приложения (Personal Programmer), обеспечивающий создание приложений для работы с БД и способный выполнять свои функции даже при отсутствии на ПЭВМ ядра СУБД. При этом как перечисленные выше компоненты, так и генератор приложений ориентированы в первую очередь на непрограммирующих пользователей. С помощью системы меню и функциональных клавиш генератора приложений пользователи могли создавать собственную конфигурацию интерактивных элементов приложения, в том числе выпадающие и иерархические меню, окна, а также средства помощи (окна со справочной информацией). Аналогичные возможности имелись практически во всех развитых СУБД.

Наряду с другими достижениями в области технологий программирования, появление объектно-ориентированных баз данных способствовало внедрению объектно-ориентированного подхода в практику создания пользовательских интерфейсов. Технология объектно-ориентированного программирования позволила еще более явно отделить друг от друга компоненты приложения, реализующие его функциональное предназначение, и компоненты, относящиеся к пользовательскому интерфейсу.

Чрезвычайно большое влияние на все последующее развитие интерактивных систем оказала растровая графика. Ее применение в качестве основы инструментов визуального программирования привело к появлению принципиально нового типа пользовательского интерфейса — графического.

Средства визуальной разработки, обеспечивающие реализацию объектно-ориентированного программирования, позволяют создавать макет пользовательского интерфейса, используя технологию *WYSIWYG* (What You See Is What You Get - «что вы видите, то и получите», то есть результат выглядит так же, как и прототип во время разработки). Средства визуальной разработки были созданы практически для всех популярных языков программирования, а также для вновь появившихся (например, для Java). Все эти инструменты обладают двумя основными достоинствами: во-первых, существенно повышают производительность труда программиста, и, во вторых, обеспечивают стандартизацию пользовательского интерфейса за счет использования однотипных базовых элементов. В результате, глядя на готовое приложение, практически невозможно определить, на каком языке и с помощью какого инструмента оно было создано.

Как и до появления средств визуального программирования, особое место среди других проблемно-ориентированных систем разработки занимают СУБД. Применение в них технологии *WYSIWYG* позволило им практически сравняться по мощности и эффективности с универсальными инструментами разработки GUI-приложений. И даже более того, наличие в СУБД средств визуального представления инфологической модели данных позволяет во многих случаях создавать более корректную модель пользовательского интерфейса по сравнению с универсальными инструментами.

В силу того, что интерфейс систем реального времени имеет целый ряд существенных особенностей (основные из которых были рассмотрены в предыдущей главе), для его построения используются, как правило, специализированные инструментальные средства. Они сформировались в результате слияния SCADA-систем (Supervisory Control And Data Acquisition system - систем сбора данных и оперативного диспетчерского управления) и средств визуального программирования «общего назначения» на

Упоминавшийся выше язык Visual Basic (точнее, одна из его спецификаций — Visual Basic Application — VBA) оказал большое влияние на технологию создания приложений, настраиваемых пользователем. Продуманность и логическая завершенность решении, предложенных Microsoft, привела к тому, что VBA прочно занял свою собственную «нишу» среди инструментальных средств формирования пользовательского интерфейса приложений. Пожалуй, в этом отношении он является даже уникальным инструментом, и не случайно многие фирмы-производители ПО лицензировали VBA у Microsoft с целью использования в качестве встроенного языка приложений.

Тем не менее, в инструментах визуального программирования поддержку получают в основном этапы жизненного никла, относящиеся к разработке и реализации приложении, и в значительно меньшей степени - относящиеся к этапам проектирования.

Указанного недостатка лишены так называемые CASE-системы (CASE - это Computer Aided Software Engineering - компьютерное проектирование программного обеспечения). Понятие CASE является весьма широким и охватывает как собственно технологию, так и средства ее реализации. Обязательным атрибутом CASE-системы является возможность автоматической (или по крайней мере автоматизированной) генерации кода программы на основе ее спецификации. Существенной особенностью CASE-систем является также поддержка практически всех основных этапов жизненного цикла создаваемого приложения, в том числе:

• Стратегическое планирование (описание целей, факторов, ресурсов; моделирование стратегии; формирование структуры плана и политики фирмы-разработчика);

• Описание предметной области (описание объектов предметной области и отношений между ними; интеграция различных моделей предметной области);

• Анализ возможностей реализации (анализ существующих проектов);

• Определение требований (моделирование потоков данных; создание и анализ прототипов; контроль полноты и согласованности требований);

• Системное проектирование (декомпозиция и сборка проекта, имитационное моделирование создаваемого приложения);

• Программирование (генерация кода и анализ его метрических характеристик);

• Тестирование (автоматическая генерация контрольных примеров, регистрация и анализ результатов тестирования);

• Документирование (создание и сопровождение библиотеки спецификаций);

• Сопровождение и управление проектом.

Как следует из перечисленных особенностей CASE-систем, их применение способствует проектированию и реализации пользовательского интерфейса, обладающего требуемыми свойствами. Более того, некоторые из таких систем имеют в своем составе компоненты, предназначенные специально для разработки пользовательского интерфейса создаваемого приложения. Например, продукт CASE/4/0 фирмы MicroTOOL GmbH содержит так называемый «дизайнер диалогов», обеспечивающий создание и моделирование пользовательского интерфейса. Вместе с тем, сами по себе CASE-системы достаточно сложны в освоении и использовании, поэтому эффективность их применения прямо пропорциональна сложности создаваемого продукта.

Существенное возрастание количества и многообразия интерактивных приложении, а также расширение области их применения обусловили наличие двух тенденций:

во-первых, все существующие инструменты создания приложений стали оцениваться (классифицироваться) помимо других критериев еще и с точки зрения их пригодности для создания пользовательского интерфейса определенного уровня;

во-вторых, появились инструментальные средств, специально предназначенные для проектирования и реализации пользовательского интерфейса.

Инструментальные средства создания пользовательского интерфейса могут быть отнесены к одному из следующих классов:

• Системы управления пользовательским интерфейсом (User Interface Management System — UIMS);

• Инструментальные средства проектирования и разработки интерфейса (Interface Builder — IB);

• Инструментальные средства разработки интерфейса (Tools&Toolkit — Т&Т);

• Средства прототипирования интерфейса (Prototyping Tools — РТ).

**Система управления пользовательским интерфейсом** (UIMS) — это интегрированный набор средств, помогающих программисту в создании и управлении различными интерфейсами пользователя. Основной концепцией U I DS является идея разделения интерфейса и прикладной программы (точнее, ее функционального наполнения).

Как правило, UIMS состоит из двух частей: одна обеспечивает разработку интерфейса, а вторая - управление пользовательским интерфейсом в процессе его работы с приложением. Многие UIMS имеют собственный язык определения интерфейса для представления требуемого диалога и генератор, которой автоматически создает необходимый код из исходного описания на этом языке. В идеале UIMS должна, с одной стороны, позволять создавать различные интерфейсы для работы с одним и тем же приложением, а с другой - поддерживать один и тот же интерфейс для различных приложений. Список наиболее распространенных UIMS, доступных через Интернет, приведен и приложении 1. Из рассмотренных выше инструментальных средств к данному классу могут быть отнесены, некоторые CASE-средства и наиболее развитые из систем типа HMI/SCADA.

Класс **инструментальных средств проектирования иразработки интерфейса** (Interface Builder) образуют средства, которые обеспечивают создание интерфейса определенного (стандартизованного) типа для различных приложений, функционирующих в соответствующей операционной среде. Примерами таких средств могут служить Visual C++ и Delphi для MS Windows, Tk/TCL для XWindows или Photon Application Builder (Phab), обеспечивающий создание GUI-приложений в графической среде Photon microGUI операционной системы QNX. Некоторые представители данного класса поддерживают только этап проектирования пользовательского интерфейса и ориентированы на совместное использование с одним из инструментов визуального программирования.

**Инструментальные средства разработки интерфейса** (Tools&Toolkit) близки по своим характеристикам представителям предыдущего класса, но либо имеют более ограниченные функциональные возможности, либо представляют собой набор (библиотеку) элементов, на основе которых могут быть реализованы различные варианты GU.

**Заключение**

Подробно изучена тема графического интерфейса. Изучили особенности графического интерфейса. Ознакомились с компонентами графического интерфейса и объективным подходом к проектированию интерфейса: общие правила взаимодействия с объектами. Рассмотрели операции пересылки и создания объектов. Ознакомились с проектированием окон и пиктограмм, а также, проектирование элементов управления: меню, кнопки, списки, текстовые области, панели инструментов, другие элементы. Рассмотрели проектирование средств поддержки пользователя, средства реализации пользовательского интерфейса.

**Контрольные вопросы:**

1.  Определение интерфейсов пользователя?
2.  Компоненты графического интерфейса?
3.  Понятие «пересылка объекта»
4.  Стандартная реализация техники drag-and-drop
5.  Разновидности средств поддержки пользователей.
